
%%%%%
% Some things will likely have to be cut. Here are some options. The number in [1,10] with each indicates the importance of the thing, with higher numbers being more important (and thus harder to cut).
%
% 2. GP Parameters table - This takes up a lot of space. While this would be needed for exactly replicating our experiments, we could succinctly and vaguely explain the parameter ranges in text and point to the implementations for exact values.
%
% 7. Table of instruction types used with each problem - This table is huge (takes up a page). But, it adds a lot to the discussion of our implementation recommendations.
%
% 3. Methods section - We might need to make this as brief as possible, with pointers to other papers (like our WC paper) for more details. 
%
% 5. Parts of the experiments section - This is currently pretty long considering it's not the focus of the paper.
%
% 1-4. Some citations - Some citations probably aren't necessary. I've marked a few in the text, especially with regards to lexicase selection, where I've cited multiple papers where a single citation might suffice. Also when citing PushGP. Also maybe the fmsb package citation for R.
%
%%%%%

\documentclass{sig-alternate}

\usepackage{tabulary}
\usepackage[hyphens]{url}
\usepackage{rotating}
\usepackage{underscore}

\graphicspath{{./Figures/}}

\begin{document}
%
% --- Author Metadata here ---
\conferenceinfo{GECCO'15,} {July 11-15, 2015, Madrid, Spain.}
\CopyrightYear{2015}
\crdata{TBA}
\clubpenalty=10000
\widowpenalty = 10000
% --- End of Author Metadata ---

%      IntroProg Benchmark Suite for General Program Synthesis
\title{General Program Synthesis Benchmark Suite}

\numberofauthors{2} 

\author{
% 1st. author
\alignauthor
Author omitted\\
       \affaddr{.}\\
       \affaddr{.}\\
       \affaddr{.}\\
       \email{.}
% 2nd. author
\alignauthor
Author omitted\\
       \affaddr{.}\\
       \affaddr{.}\\
       \affaddr{.}\\
       \email{.}
}

\maketitle

\begin{abstract}
Recent interest in the use and development of non-trivial benchmark problems in genetic programming has uncovered the lack of useful general program synthesis (sometimes called ``traditional programming'') benchmark problems. Most genetic programming benchmark problems prescribe small, domain-specific instruction sets; general program synthesis instead requires the type of programming expected of human programmers using higher-level programming languages. Problems of this type require a range of programming ``skills'', such as the utilization of control flow and modularity and the employment of large, diverse instruction sets covering multiple data types and data structures. In this paper, we present a suite of 29 new general programming benchmark problems, systematically selected from sources of introductory computer science programming problems. While we primarily intend to use this benchmark suite with genetic programming systems, we designed it with sufficient generality for any program synthesis system that takes program specifications from input/output examples. Our program descriptions and statistical recommendations allow the implementation and application of these problems in any program synthesis system; we also present a reference implementation. We finally present results from an illustrative experiment, showing the range of difficulties presented in the problems as well as the utility of the benchmark suite.
\end{abstract}

\category{I.2.2}{Artificial Intelligence}{Automatic Programming}[Program synthesis]

%% A category with the (minimum) three required fields
%\category{H.4}{Information Systems Applications}{Miscellaneous}
%%A category including the fourth, optional field follows...
%\category{D.2.8}{Software Engineering}{Metrics}[complexity measures, performance measures]

%\terms{Theory}

\keywords{program synthesis; genetic programming; benchmark}

\section{Introduction}



[THE FOLLOWING HAS BEEN COPIED FROM THE INTRO OF THE WC PAPER; SOMETHING ALONG THESE LINES BUT CONDENSED BELONGS IN THE INTRO.]
The GP community has recently discussed the need for better benchmarks \cite{McDermott:2012:GECCO, White:2013:BGB:2441218.2441242}. These discussions provide recommended benchmarks for some problem domains, but not for traditional programming problems (which they call ``algorithmic programming'' problems), despite the traditional programming category receiving the second most votes in a community survey asking what types of problems a GP benchmark suite should contain \cite{White:2013:BGB:2441218.2441242}. Traditional programming problems mimic the programming of human programmers, requiring multiple data types, control flow, and a large instruction set. Automating human programming tasks has long been a goal of GP, as articulated in Koza's first book \cite{koza:book} for example. The absence of traditional programming problems among current recommended benchmarks is unfortunate and should be addressed.



\section{Methods of Comparison}

The goal of a general programming problem is to synthesize a program that perfectly maps the given inputs to the desired outputs. This goal reflects the desired outcome for general program synthesis; a program that passes most, but not all, of a set of test cases usually is unhelpful for this type of problem. When measuring the performance of a system on the problems in this suite, we only care about finding perfect solution programs; incremental improvements in programs provide no utility unless they result in a program that passes all tests.

``Success rate'' measures how often a stochastic algorithm finds a successful program across a set of runs; we recommend this statistic when comparing systems or settings on the types of general program synthesis problems in this suite\footnote{When using a deterministic synthesis algorithm, other statistics must be used such as whether a successful program is found within a set period of time.}; a more thorough argument for success rate can be found in \cite{Helmuth:2014:GECCO}.
In order to be considered successful, a program must not only achieve zero error on all of the example data used to train the program (the ``training set''), but also a set of withheld generalization data (the ``test set''). Since we do not want to require formal specifications for the problem, this test set is the best way to test whether a program actually solves the problem or instead memorizes the training set.

%should we cite WC paragraph for having a more detailed discussion of these things somewhere in here? --> DONE: cited mid-paragraph above

[THIS PARAGRAPH TAKEN FROM WC PAPER; SHOULD WE HAVE SOMETHING LIKE IT HERE?] We argue more generally that the ability to solve a general program synthesis benchmark problem perfectly does not indicate the triviality of the problem. If our goal is to someday have GP or other synthesis systems generate complex software that performs important functionality without having to be coded by humans, we would hope that such a system would pass all of its tests before going into use. The purpose of general program synthesis benchmark problems is to compare the performances of GP methods on general program synthesis problems; as such, we would expect GP to be able to solve them in order to have a hope of solving real programming problems.

%Statistical procedure -- maybe leave out? Would talk about chi-square tests and Fisher's exact test. (leaving out for now)

When using this benchmark suite to compare different settings within one system, we recommend limiting computation with a computational budget based on the maximum number of program evaluations allowed in a run. This ensures that the methods receive similar computational work. On the other hand, using benchmark problems to perform cross-system comparisons can lead to complications without care. There are steps one can take to improve comparability but it will never be absolute, because there will probably be many unavoidable differences between systems that will play out in complicated ways for specific problems. In many cases, the interesting question to ask vis-a-vis a particular system on a particular problem is whether it can solve it at all, and if so, then whether it can solve it reasonably reliably; more subtle claims may be difficult to justify. Trying to compare computational effort, runtime, etc. is likely to be unhelpful. Nonetheless, we aim here to describe specifications that will allow for as much cross-system comparability as possible. % A lot of this paragraph is copied from a Lee email; it sounded good, so I kept it with minor editing.


\section{Requirements} \label{requirements}

In this section we describe the requirements we used when selecting problems for this benchmark suite, as well as the requirements for a program synthesis systems to be applied to the problems. Some of our requirements overlap with those described in the GP benchmarks papers \cite{McDermott:2012:GECCO, White:2013:BGB:2441218.2441242}, such as being varied, relevant, realistically difficult, representation-independent, and precisely-defined. Other proposed requirements have less relevance to this set of problems because of the general program synthesis domain we target.

This benchmark suite targets program synthesis systems that use example inputs and their corresponding outputs as the specifications for the desired program. In the context of genetic programming, we call these input/output pairs \textit{fitness cases} for the problem. Thus, a problem must be defined on a range of inputs that have known correct outputs; it cannot simply ask to calculate a specific value. For example, a problem that requires the program to calculate the number of prime numbers less than 1000 would not qualify, since it only has one answer; but, a similar problem that requires the program to calculate the number of prime numbers less than an input integer $n$ would meet this requirement, since we could then provide example inputs for $n$ and their corresponding desired outputs. This requirement also ensures that fitness cases can be generated to fill the training and test set, as required to ensure generalization of successful programs.

Problems in the suite should present challenges typical of real general program synthesis applications. The goal of a benchmark problem is to measure the characteristics of a system on a problem that mimics some aspects of the real applications on which it is expected to function. In order to test general program synthesis from examples, we want to choose benchmark problems that require a range of programming constructs and data types. Additionally, they should require a variety of sizes and shapes for solution programs, not limited to artificially small programs. Such a benchmark suite will not likely include problems that significantly challenge advanced human programmers, but should at least prove challenging to new programmers.

Finally, the benchmarks should not be biased toward a particular method of synthesis. The problems presented here should be accessible to many forms of program synthesis, including a variety of genetic programming systems as well as other analytic and search-based program synthesis systems. Since systems generate programs in a variety of languages, problems that require a specific language feature or non-standard data type (such as Java objects) will be avoided.

For a synthesis system to be applicable to the problems in this suite, it needs to take input/output examples as program specifications. It must be able to produce programs that manipulate the data types necessary to solve the problems, which includes the ability to print outputs and return functional results. Any synthesis system that meets these requirements may be applied to these problems.


\section{Problem Descriptions} \label{descriptionsSection}

This section describes the problems in this benchmark suite, which we chose to take exclusively from introductory computer science programming problems. This type of problem tests whether a system can perform at a similar level to a human who is learning to program. They also require a wide range of programming constructs and use a variety of data types. By selecting external sources for problems and then using all problems that meet the requirements we defined in Section \ref{requirements}, we hopefully avoid biasing the selection of problems toward those solvable by our system.

We have selected two sources for problems: iJava \cite{iJava}, an interactive textbook for introductory computer science, and IntroClass \cite{ManyBugsAndIntroClass, Brun13TRgptest}, a set of problems originally used as benchmarks for automatic program repair. Below we describe each of these sources in further detail, along with the problems selected from each source.

\subsection{iJava}

In this section, we will describe the problems from iJava \cite{iJava, Moll:2011:IOI:1968521.1968535}. iJava is an interactive introductory computer science textbook that contains a number of automatically graded programming problems. These problems work well for general program synthesis from examples, since they are often graded by testing programs against a range of inputs.

The problems we selected appear in iJava edition 3.1. iJava contains some sections of problems that vary slightly but otherwise test very similar programming skills; in these cases, we chose one representative problem from the group, ensuring a reasonable distribution of problem requirements. Below, we present a natural language description as might be described to human programmers for the 23 problems chosen from iJava, and provide the question or project number associated with the problem in iJava 3.1.


\subsubsection*{1. Number IO (Q 3.5.1)}
Given an integer and a float, print their sum.

\subsubsection*{2. Small or Large (Q 4.6.3)}
Given an integer $n$ in the range $[-10000, 10000]$, print ``small'' if $n < 1000$ and ``large'' if $n \ge 2000$ (and nothing if $1000 \le n < 2000$).

\subsubsection*{3. For Loop Index (Q 4.11.7)}
Given 3 integer inputs $start, finish,$ and $stepSize$, print the integers represented by the Java for loop: \\
\texttt{for(i = start; i < finish; i += stepSize) \\ \- \- \- \- System.out.println(i);}

\subsubsection*{4. Compare String Lengths (Q 4.11.13)}
Given three strings $n1$, $n2$, and $n3$, return true if $length(n1) < length(n2) < length(n3)$, and false otherwise.

\subsubsection*{5. Double Letters (Project 4.1)}
Given a string, print the string, doubling every letter character, and tripling every exclamation point. All other non-alphabetic and non-exclamation characters should be printed a single time each.

\subsubsection*{6. Collatz Numbers (Project 4.2)}
Given an integer, find the number of terms in the Collatz sequence starting from that integer.

\subsubsection*{7. Replace Space with Newline (Project 4.3)}
Given a string input, print the string, replacing spaces with newlines. Also, return the integer count of the non-whitespace characters. The input string will not have tabs or newlines, but may have multiple spaces in a row.

\subsubsection*{8. String Differences (Project 4.4)}
Given 2 strings (without whitespace) as input, find the indices at which the strings have different characters, stopping at the end of the shorter one. For each such index, print a line containing the index as well as the character in each string. For example, if the strings are ``dealer'' and ``dollars'', the program should report this: \\
\texttt{\centerline{1 e o} \\
\centerline{2 a l} \\
\centerline{4 e a}}

\subsubsection*{9. Even Squares (Q 5.4.1)}
Given an integer $n$, print all of the positive even perfect squares less than $n$ on separate lines.

\subsubsection*{10. Wallis Pi (Project 6.4))}
John Wallis gave the following infinite product that converges to $\pi/4$:
\[
\frac{2}{3}\times \frac{4}{3}\times \frac{4}{5}\times \frac{6}{5}\times \frac{6}{7}\times \frac{8}{7}\times \frac{8}{9}\times \frac{10}{9} \times ...
\]
Given an integer input $n$, compute an approximation of this product out to $n$ terms. Results are rounded to 5 decimal places.

\subsubsection*{11. String Lengths Backwards (Q 7.2.5)}
Given a vector of strings, print the length of each string in the vector starting with the last and ending with the first.

\subsubsection*{12. Last Index of Zero (Q 7.7.8)}
Given a vector of integers, at least one of which is 0, return the index of the last occurrence of 0 in the vector.

\subsubsection*{13. Vector Average (Q 7.7.11)}
Given a vector of floats, return the average of those floats. Results are rounded to 4 decimal places.

\subsubsection*{14. Count Odds (Q 7.7.12)}
Given a vector of integers, return the number of integers that are odd, without use of a specific \texttt{even} or \texttt{odd} instruction.

\subsubsection*{15. Mirror Image (Q 7.7.15)}
Given two vectors, return true if one vector is the reverse of the other, and false otherwise.

\subsubsection*{16. Super Anagrams (Project 7.3)}
Given strings $x$ and $y$ of lowercase letters, return true if $y$ is a super anagram of $x$, which is the case if every character in $x$ is in $y$. To be true, $y$ may contain extra characters, but must have at least as many copies of each character as $x$ does.

\subsubsection*{17. Sum of Squares (Q 8.5.4)}
Given integer $n$, return the sum of squaring each integer in the range $[1, n]$.

\subsubsection*{18. Vectors Summed (Q 8.7.6)}
Given two vectors of integers, return a vector of integers that contains the sum of the input vectors at each index.

\subsubsection*{19. X-Word Lines (Project 8.1)}
Given an integer $X$  and a string that likely contains spaces and newlines, print the string with exactly $X$ words per line. The last line may have fewer than $X$ words.

\subsubsection*{20. Pig Latin (Project 8.2)}
Given a string containing lowercase words separated by single spaces, print the string with each word translated to pig Latin. More specifically, if a word starts with a vowel, it should have ``ay'' added to its end; otherwise, the first letter is moved to the end of the word, followed by ``ay''.

\subsubsection*{21. Negative To Zero (Q 9.6.8)}
Given a vector of integers, return the vector where all negative integers have been replaced by 0.

\subsubsection*{22. Scrabble Score (Project 10.1)}
Given a string of visible characters, return the Scrabble score for that string. Each letter has a corresponding value according to normal Scrabble rules, and non-letter characters are worth zero.

\subsubsection*{23. Word Stats (Project 10.5)}
Given a file, print the number of words containing $n$ characters for $n$ from 1 to the length of the longest word, in the format:
\texttt{ \\
words of length 1: 12 \\
words of length 2: 3 \\
words of length 3: 8 \\
... \\
} %this looks terrible -- is there something better?
At the end of the output, print a line that gives the number of sentences, and line that gives the average number of words per sentence, using the form:
\texttt{ \\
number of sentences: 4 \\
average sentence length: 7.452423455 \\
} %this looks terrible -- is there something better?
A word is any string of consecutive non-whitespace characters (including sentence terminators). Every input will contain at least one sentence terminator (period, exclamation point, or question mark). The average number of words is the number of words in the file divided by the number of sentence terminator characters.

\subsection{IntroClass}

In this section, we will describe the problems from the IntroClass dataset \cite{ManyBugsAndIntroClass, Brun13TRgptest}. This set of 6 problems was designed for the purpose of benchmarking automatic software defect repair systems. As such, the authors of this dataset provide a number of buggy programs written by students trying to solve each problem, taken from students in an introductory computer science class. For the purposes of automatic program synthesis from scratch, we will use the problems themselves but not the accompanying buggy programs. Since these problems were designed for automatic defect repair, they all can be tested on a range of inputs, and require outputs to be printed.

\subsubsection*{24. Checksum}
Given a string, compute the integer values of the characters in the string, sum them, take the sum modulo 64, add the integer value of the space character, and then convert that integer back into its corresponding character (the checksum character). The program must print \texttt{Check sum is X}, where $X$ is replaced by the correct checksum character.

\subsubsection*{25. Digits}
Given an integer, print that integer's digits each on their own line starting with the least significant digit. A negative integer should have the negative sign printed before the most significant digit.

\subsubsection*{26. Grade}
Given 5 integers, the first four represent the lower numeric thresholds for achieving an A, B, C, and D, and will be distinct and in descending order. The fifth represents the student's numeric grade. The program must print \texttt{Student has a X grade.}, where $X$ is A, B, C, D, or F depending on the thresholds and their numeric grade.

\subsubsection*{27. Median}
Given 3 integers, print their median.

\subsubsection*{28. Smallest}
Given 4 integers, print the smallest of them.

\subsubsection*{29. Syllables}
Given a string containing symbols, spaces, digits, and lowercase letters, count the number of occurrences of vowels (a, e, i, o, u, y) in the string and print that number as $X$ in \texttt{The number of syllables is X}.

\section{Synthesis Problem\\Specifications} \label{synthProbSpec}

The natural language descriptions of the benchmark problems in Section \ref{descriptionsSection} contain insufficient details to implement specifications for each desired program in a program synthesis system. In this section we discuss issues related to defining problems so that they are interpretable by program synthesis systems. These specifications will allow the benchmark problems to be implemented in a variety of systems and should be technique-independent, while ensuring that different implementations are solving the ``same problem''.

\begin{table*}[t]
\centering
\caption{For each problem, the types of the inputs and outputs, and the limits imposed on the inputs. Any printed outputs should be printed by the program to standard output. The columns Train and Test indicate the recommended sizes of the training set and test set respectively. (NB: RESULTS FOR SUM OF SQUARES USES 20 TRAIN CASES; KEEP 50 ONLY IF NEW RUNS BETTER.)}
\label{testCasesTable}
%{\renewcommand{\arraystretch}{1}%
\begin{tabular}{|l | >{\raggedright}p{7.4cm} l rr|}
\hline
\textbf{Name} & \textbf{Inputs} & \textbf{Outputs} & \textbf{Train} & \textbf{Test} \\
\hline
\hline
Number IO & integer in $[-100, 100]$, float in $[-100.0, 100.0]$ & printed float & 25 & 1000 \\
\hline
Small Or Large & integer in $[-10000, 10000]$ & printed string & 100 & 1000 \\
\hline
For Loop Index & integers \texttt{start} and \texttt{end} in $[-500, 500]$, \texttt{step} in $[1, 10]$ & printed integers & 100 & 1000 \\
\hline
Compare String Lengths & 3 strings of length $[0, 49]$ & boolean & 100 & 1000 \\
\hline
Double Letters & string of length $[0, 20]$ & printed string & 100 & 1000 \\
\hline
Collatz Numbers & integer in $[1, 10000]$ & integer & 200 & 2000 \\
\hline
Replace Space with Newline & string of length $[0, 20]$ & printed string, integer & 100 & 1000 \\
\hline
String Differences & 2 strings of length $[0, 10]$ & printed string & 200 & 2000 \\
\hline
Even Squares & integer in $[1, 9999]$ & printed string & 100 & 1000 \\
\hline
Wallis Pi & integer in $[1, 200]$ & float & 150 & 50 \\
\hline
String Lengths Backwards & vector of length $[0, 50]$ of strings of length $[0, 50]$ & printed string & 100 & 1000 \\
\hline
Last Index of Zero & vector of integers of length $[1, 50]$ with each integer in $[-50, 50]$ & integer & 150 & 1000 \\
\hline
Vector Average & vector of floats of length $[1,50]$ with each float in $[-1000.0, 1000.0]$ & float & 100 & 1000 \\
\hline
Count Odds & vector of integers of length $[0,50]$ with each integer in $[-1000, 1000]$ & integer & 200 & 2000 \\
\hline
Mirror Image & 2 vectors of integers of length $[0,50]$ with each integer in $[-1000, 1000]$ & boolean & 100 & 1000 \\
\hline
Super Anagrams & 2 strings of length $[0, 20]$ & boolean & 200 & 2000 \\
\hline
Sum of Squares & integer in $[1, 100]$ & integer & 50 & 50 \\
\hline
Vectors Summed & 2 vectors of integers of length $[0,50]$ with each integer in $[-1000, 1000]$ & vector of integers & 150 & 1500 \\
\hline
X-Word Lines & integer in $[1, 10]$, string of length $[0, 100]$ & printed string & 150 & 2000 \\
\hline
Pig Latin & string of length $[0, 50]$ & printed string & 200 & 1000 \\
\hline
Negative To Zero & vector of integers of length $[0,50]$ with each integer in $[-1000, 1000]$ & vector of integers & 200 & 2000 \\
\hline
Scrabble Score & string of length $[0, 20]$ & integer & 200 & 1000 \\
\hline
Word Stats & file containing $[1, 100]$ chars & printed string & 100 & 1000 \\
\hline
Checksum & string of length $[0, 50]$ & printed string & 100 & 1000 \\
\hline
Digits & integer in $[-9999999999, 9999999999]$ & printed integers & 100 & 1000 \\
\hline
Grade & 5 integers in $[0, 100]$ & printed string & 200 & 2000 \\
\hline
Median & 3 integers in $[-100, 100]$ & printed integer & 100 & 1000 \\
\hline
Smallest & 4 integers in $[-100, 100]$ & printed integer & 100 & 1000 \\
\hline
Syllables & string of length $[0, 20]$ & printed string & 100 & 1000\\
\hline
\end{tabular}
\end{table*}

Table \ref{testCasesTable} presents information related to the sets of training and test data for each problem. These recommendations, like the rest in this section, are not set in stone; instead, they present guidelines that should be followed where possible. Adhering to these guidelines closely will create results with more legitimate comparability to the results presented here. The table describes the data types of the inputs and outputs and gives reasonable ranges for program inputs. Note that some problems specify that outputs are printed to standard output, a requirement exhibited often in human-written code but rarely seen in automatic program synthesis previously. These problems explicitly required the printing of results in their original sources.

We also provide recommendations for numbers of example cases to use in the train and test sets for each problem in Table \ref{testCasesTable}. For most problems, we recommend between 100 and 200 training cases, depending on the difficulty of the problem as well as the dimensionality of the input space. A few problems use fewer, either because they have limited input space or are simple enough to solve with fewer cases. The size of the test set used to test generalization of solution programs to unseen data is usually recommended to be ten times as large as the training set; again, there are exceptions for problems with limited input spaces. The method of producing the training and test cases is system-specific; we recommend a combination of hand-chosen edge cases with randomly generated cases, and will describe our method in more detail in Section \ref{systemParamsSection}.

% Table 2 prior location

The question of which instructions to make available for a synthesis system to use for each problem is a complex one. It is important to not cherry pick a small set of instructions that are known to be sufficient to solve a problem; such a selection may be difficult for a real-world problem, where it might not be clear which instructions will be useful. On the other hand, using all available instructions for every problem expands the search space and may make problems more difficult than necessary. Our recommendation is to compromise between these approaches by first determining what data types are required for each instruction in the instruction set, and then deciding which data types could be useful in solving each problem and using the relevant instructions. For example, an instruction that compares the equality of two integers and returns a boolean would be included if the problem could potentially make use of integers and booleans. By specifying only the data type requirements for a problem, we can limit the number of instructions without cherry picking. 


\section{System Parameters} \label{systemParamsSection}

Where Section \ref{synthProbSpec} gave technique-independent recommendations for specifying the benchmark problems, this section will give more detail about the system-specific parameters and decisions that must be made in order to implement these problems in a given program synthesis system. This discussion will focus on genetic programming as the synthesis technique, but will also have relevance to non-evolutionary techniques. In this discussion we will give examples from our reference implementation, the PushGP genetic programming system.

PushGP evolves programs in Push, a stack-based programming language designed specifically for GP \cite{spector2:2001:gecco, spector:2002:GPEM, 1068292}. % Maybe remove one or two of these citations?
Push provides many tools important for general program synthesis, such as multiple data types, control flow, and the use of input/output examples as specifications. While we chose PushGP as the reference implementation of these problems and for our example experiment, we emphasize that these are just examples, and that the problems here could be used in any system that meets the requirements in Section \ref{requirements}.

The reference implementation of these problems in PushGP can be found in the GitHub repository\footnote{PUT REPOSITORY WEBSITE HERE}. In the rest of this section, we will describe some of the major decisions necessary for implementing these benchmark problems. As we will not have space to discuss every parameter and implementation choice, the problem files in the reference implementation can be used to illustrate the details we omit.

When generating input examples to use for training and testing data, we use a combination of hand-picked edge cases that remain constant across runs and randomly generated inputs that vary each run. For each problem, we specify one or more ``data domains'' \cite{Helmuth:2014:GECCO}, which consist of either a set of hard-coded inputs or a random input generator, as well as the number of training and test cases that should come from each domain. Details of generating inputs from data domains can be found in \cite{Helmuth:2014:GECCO}, and our reference implementation gives our choices for data domains for each problem\footnotemark[1] (CORRECT?).

When using this benchmark with genetic programming, we need not only the example input/output cases, but also a method of measuring how well a particular program performs on each case---the \textit{fitness function}. Fitness functions for these problems must not only match their respective output types, but must also give reasonable measurement of program performance, tailored to the problem. %maybe take out that last part.
Still, we can present some generalities of our chosen fitness functions before pointing to the reference implementation for details.

Many of the problems in this suite print results to standard output. We treat these outputs as strings and usually use Levenshtein distance as the fitness function. Levenshtein distance is a string edit distance metric that we use to compare the desired output string and the one printed by the program. Other problems produce numeric outputs, including returned integers and floats as well as printed versions of each. For these problems we use absolute error for fitness. Some problems produce boolean values, or are best measured by a simple binary right or wrong; here, we use a boolean fitness of 0 for right and 1 for wrong. Finally, some problems require very specific fitness functions, such as vector edit distance or string formatting requirements.

Some problems produce results that can better be handled by multiple error functions per training or test case. For example, the Replace Space With Newline problem requires both a printed string and a returned integer. For problems like this, we simply produce multiple fitness values for a single case. Additionally, some problems may not necessitate the use of multiple fitness values per case, but we have found better performance when we use them.

\begin{table*}%[t]
\centering
\caption{Instructions and data types used in our PushGP implementation of each problem. The column ``\# Instructions'' reports the number of instructions, terminals, and ERCs used for each problem. The middle columns show which data types were used for each problem. For example, the Number IO problem used all instructions that use integers, floats, and printing. The last column lists the constants and ERCs used for the problem. Here, char constants are represented in the Clojure style, starting with a backslash, and strings are surrounded by double quotation marks. The ``Problems Using Type'' row simply counts how many problems use each data type. The ``Instructions for Type'' row shows the number of Push instructions that primarily use each data type; some use multiple types but are only counted once (e.g. \texttt{integer\_fromfloat}, which requires both integer and float to be used).}
\label{tableDataTypes}
\begin{tabular}{|>{\raggedright}p{3.1cm}|c|ccccccccccc|>{\raggedright}p{5.5cm}|}
\hline
\textbf{Problem} & \begin{sideways}\textbf{\# Instructions} \- \end{sideways} & \begin{sideways}\textbf{exec}\end{sideways} & \begin{sideways}\textbf{integer}\end{sideways} & \begin{sideways}\textbf{float}\end{sideways} & \begin{sideways}\textbf{boolean}\end{sideways} & \begin{sideways}\textbf{char}\end{sideways} &  \begin{sideways}\textbf{string}\end{sideways} & \begin{sideways}\textbf{vector of integers} \- \end{sideways} & \begin{sideways}\textbf{vector of floats}\end{sideways} & \begin{sideways}\textbf{vector of strings}\end{sideways} & \begin{sideways}\textbf{print}\end{sideways} & \begin{sideways}\textbf{file input}\end{sideways} & \textbf{Terminals (besides inputs)} \tabularnewline
\hline
\hline
Number IO                  & 50              &      & x       & x     &         &      &        &                    &                  &                   & x     &            & integer ERC, float ERC                                                                                                                                                                                                      \tabularnewline
\hline
Small Or Large             & 103             & x    & x       &       & x       &      & x      &                    &                  &                   & x     &            & ``small'', ``large'', integer ERC                                                                                                                                                                                               \tabularnewline
\hline
For Loop Index             & 74              & x    & x       &       & x       &      &        &                    &                  &                   & x     &            &                                                                                                                                                                                                                             \tabularnewline
\hline
Compare String Lengths     & 98              & x    & x       &       & x       &      & x      &                    &                  &                   &       &            & boolean ERC                                                                                                                                                                                                                 \tabularnewline
\hline
Double Letters             & 132             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & \textbackslash !                                                                                                                                                                                                            \tabularnewline
\hline
Collatz Numbers            & 102             & x    & x       & x     & x       &      &        &                    &                  &                   &       &            & 0, 1, integer ERC                                                                                                                                                                                                           \tabularnewline
\hline
Replace Space with Newline & 135             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & \textbackslash space, \textbackslash newline, string ERC, char ERC                                                                                                                                                          \tabularnewline
\hline
String Differences         & 135             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & \textbackslash space, \textbackslash newline, integer ERC                                                                                                                                                                   \tabularnewline
\hline
Even Squares               & 72              & x    & x       &       & x       &      &        &                    &                  &                   & x     &            &                                                                                                                                                                                                                             \tabularnewline
\hline
Wallis Pi                  & 103             & x    & x       & x     & x       &      &        &                    &                  &                   &       &            & 2 integer ERCs, 2 float ERCs                                                                                                                                                                                                \tabularnewline
\hline
String Lengths Backwards   & 134             & x    & x       &       & x       &      & x      &                    &                  & x                 & x     &            & integer ERC                                                                                                                                                                                                                 \tabularnewline
\hline
Last Index of Zero         & 101             & x    & x       &       & x       &      &        & x                  &                  &                   &       &            & 0                                                                                                                                                                                                                           \tabularnewline
\hline
Vector Average             & 88              & x    & x       & x     &         &      &        &                    & x                &                   &       &            &                                                                                                                                                                                                                             \tabularnewline
\hline
Count Odds                 & 104             & x    & x       &       & x       &      &        & x                  &                  &                   &       &            & 0, 1, 2, integer ERC                                                                                                                                                                                                        \tabularnewline
\hline
Mirror Image               & 102             & x    & x       &       & x       &      &        & x                  &                  &                   &       &            & boolean ERC                                                                                                                                                                                                                 \tabularnewline
\hline
Super Anagrams             & 129             & x    & x       &       & x       & x    & x      &                    &                  &                   &       &            & boolean ERC, char ERC, integer ERC                                                                                                                                                                                          \tabularnewline
\hline
Sum of Squares             & 71              & x    & x       &       & x       &      &        &                    &                  &                   &       &            & 0, 1, integer ERC                                                                                                                                                                                                           \tabularnewline
\hline
Vectors Summed             & 68              & x    & x       &       &         &      &        & x                  &                  &                   &       &            & {[}{]}, integer ERC                                                                                                                                                                                                         \tabularnewline
\hline
X-Word Lines               & 134             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & \textbackslash newline, \textbackslash space                                                                                                                                                                                \tabularnewline
\hline
Pig Latin                  & 141             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & ``ay'', \textbackslash space, \textbackslash a, \textbackslash e, \textbackslash i, \textbackslash o, \textbackslash u, ``aeiou'', string ERC, char ERC                                                                         \tabularnewline
\hline
Negative To Zero           & 102             & x    & x       &       & x       &      &        & x                  &                  &                   &       &            & 0, {[}{]}                                                                                                                                                                                                                   \tabularnewline
\hline
Scrabble Score             & 158             & x    & x       &       & x       & x    & x      & x                  &                  &                   &       &            & vector containing Scrabble values (indexed by ASCII values)                                                                                                                                                                 \tabularnewline
\hline
Word Stats                 & 281             & x    & x       & x     & x       & x    & x      & x                  & x                & x                 & x     & x          & \textbackslash ., \textbackslash ?, \textbackslash !, \textbackslash space, \textbackslash tab, \textbackslash newline, {[}{]}, ``words of length '', ``: '', ``number of sentences: '', ``average sentence length: '', integer ERC \tabularnewline
\hline
Checksum                   & 136             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & ``Check sum is '', \textbackslash space, 64, integer ERC, char ERC                                                                                                                                                            \tabularnewline
\hline
Digits                     & 133             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & \textbackslash newline, integer ERC {[}-10, 10{]}                                                                                                                                                                           \tabularnewline
\hline
Grade                      & 112             & x    & x       &       & x       &      & x      &                    &                  &                   & x     &            & ``Student has a '', `` grade.'', ``A'', ``B'', ``C'', ``D'', ``F'', integer ERC                                                                                                                                                           \tabularnewline
\hline
Median                     & 75              & x    & x       &       & x       &      &        &                    &                  &                   & x     &            & integer ERC                                                                                                                                                                                                                 \tabularnewline
\hline
Smallest                   & 76              & x    & x       &       & x       &      &        &                    &                  &                   & x     &            & integer ERC                                                                                                                                                                                                                 \tabularnewline
\hline
Syllables                  & 141             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & ``The number of syllables is '', ``aeiouy'', \textbackslash a, \textbackslash e, \textbackslash i, \textbackslash o, \textbackslash u, \textbackslash y, char ERC, string ERC                                                   \tabularnewline
\hline
\hline
Problems Using Type                      &                 & 28   & 29      & 5     & 26      & 11   & 15     & 7                  & 2                & 2                 & 17    & 1          &                                                                                                                                                                                                                             \tabularnewline
\hline
Instructions for Type     &                 & 28   & 28      & 31    & 19      & 17   & 39     & 31                 & 31               & 31                & 10    & 4          &                                                                                                                                                                                                                             \tabularnewline
\hline
\end{tabular}
\end{table*}

As discussed in Section \ref{synthProbSpec}, we have chosen to specify the data types relevant to each problem, and then include all instructions that use those data types in each problem's instruction set. Table \ref{tableDataTypes} presents the Push data types we chose for each problem. The ``exec'' column signifies instructions that use Push's exec stack, which typically perform control flow manipulations such as conditionals, iteration, and subfunctions defined through tagging \cite{Spector:2011:GECCO}. The ``print'' column includes instructions that print data to standard output, and ``file input'' includes a small set of file reading instructions. The data types for instructions will vary per system, and instruction categories should not be constrained to those used here.

Table \ref{tableDataTypes} also gives the terminals used for each problem, which encompass constants and ephemeral random constants (ERCs). ERCs allow for the creation of random constants in randomly generated code during initialization and mutation. We used problem-specific constant ranges, which can be found in the reference implementation\footnotemark[1] (CORRECT?).

The second column in Table \ref{tableDataTypes} gives the number of instructions and terminals we used in our implementation of the benchmark problems in PushGP. The number of instructions used in other implementations of these problems will likely vary somewhat depending on the language in which programs are synthesized. These instructions should include a wide range of general purpose programming instructions similar to those used in modern high-level programming languages. The high numbers of instructions used for these general programming problems differs from most prior applications of GP and other program synthesis techniques, which often use small, domain-specific instruction sets.

\begin{table}[h]
\centering
\caption{GP Parameters}
\label{tableGPParameters}
\begin{tabular}{|>{\raggedright}m{2.5cm} | >{\raggedleft}p{0.6cm} >{\raggedleft}p{0.8cm} >{\raggedleft}p{0.6cm}   >{\raggedleft}p{1.6cm}|}
\hline
Problem                    & Max Prog Size & Eval Limit & Max Gens & Program Evaluation Budget \tabularnewline
\hline
Number IO                  & 200           & 200            & 200      & 5,000,000                 \tabularnewline
Small Or Large             & 200           & 300            & 300      & 30,000,000                \tabularnewline
For Loop Index             & 300           & 600            & 300      & 30,000,000                \tabularnewline
Compare String Lengths     & 400           & 600            & 300      & 30,000,000                \tabularnewline
Double Letters             & 800           & 1600           & 300      & 30,000,000                \tabularnewline
Collatz Numbers            & 600           & 15000          & 300      & 60,000,000                \tabularnewline
Replace Space with Newline & 800           & 1600           & 300      & 30,000,000                \tabularnewline
String Differences         & 1000          & 2000           & 300      & 60,000,000                \tabularnewline
Even Squares               & 400           & 2000           & 300      & 30,000,000                \tabularnewline
Wallis Pi                  & 600           & 8000           & 300      & 45,000,000                \tabularnewline
String Lengths Backwards   & 300           & 600            & 300      & 30,000,000                \tabularnewline
Last Index of Zero         & 300           & 600            & 300      & 45,000,000                \tabularnewline
Vector Average             & 400           & 800            & 300      & 30,000,000                \tabularnewline
Count Odds                 & 500           & 1500           & 300      & 60,000,000                \tabularnewline
Mirror Image               & 300           & 600            & 300      & 30,000,000                \tabularnewline
Super Anagrams             & 800           & 1600           & 300      & 60,000,000                \tabularnewline
Sum of Squares             & 400           & 4000           & 300      & 15,000,000                \tabularnewline
Vectors Summed             & 500           & 1500           & 300      & 45,000,000                \tabularnewline
X-Word Lines               & 800           & 1600           & 300      & 45,000,000                \tabularnewline
Pig Latin                  & 1000          & 2000           & 300      & 60,000,000                \tabularnewline
Negative To Zero           & 500           & 1500           & 300      & 60,000,000                \tabularnewline
Scrabble Score             & 1000          & 2000           & 300      & 60,000,000                \tabularnewline
Word Stats                 & 1000          & 6000           & 300      & 30,000,000                \tabularnewline
Checksum                   & 800           & 1500           & 300      & 30,000,000                \tabularnewline
Digits                     & 300           & 600            & 300      & 30,000,000                \tabularnewline
Grade                      & 400           & 800            & 300      & 60,000,000                \tabularnewline
Median                     & 200           & 200            & 200      & 20,000,000                \tabularnewline
Smallest                   & 200           & 200            & 200      & 20,000,000                \tabularnewline
Syllables                  & 800           & 1600           & 300      & 30,000,000                \tabularnewline
\hline
\end{tabular}
\end{table}

When considering system parameters for GP specifically, we keep most constant across all problems. The only crucial parameters that we vary per problem are the maximum program size, the maximum number of instruction evaluations that a program may use per execution, and the maximum number of generations per run. (Either: [These are in Table \ref{tableGPParameters}.] or [GIVE BRIEF DESCRIPTION OF EACH AND SAY SEE REFERENCE IMPLEMENTATION WEBSITE FOR DETAILS.])

Note that by specifying the maximum generations, the population size (1000 for all of our runs), and the size of the training set (see Table \ref{testCasesTable}), we also specify the program evaluation budget, which is the product of those values (AND GIVEN IN Table \ref{tableGPParameters}). For other systems, even non-GP systems, to produce comparable results, we recommend using the same program evaluation budget, regardless of other system settings.

\section{Experiment}

Where the relevance of a benchmark suite is determined by how well its problems reflect potential applications of the test systems, its utility is based on how well it differentiates between different approaches. We aim to include problems with a large range of difficulties, from those that can be solved reliably to those that extend beyond the abilities of current program synthesis systems. More importantly, we hope to include problems that are solved more often with some systems or settings than others, allowing us to compare their performances on these problems.

In this section we present a simple experiment showing the utility of the benchmark suite presented here. This experiment compares three parent selection algorithms: lexicase selection, tournament selection, and implicit fitness sharing.

Lexicase selection \cite{Helmuth:2014:ieeeTEC, Spector:2012:APM:2330784.2330846}, %maybe remove the second citation here if need space?
 unlike tournament selection and implicit fitness sharing, does not base selection on a single fitness value derived from the errors calculated when running the program on the training set. Instead, it uses a random ordering of the training cases to select individuals that perform as well as possible on a subset of the training cases even if they exhibit poor performance on other cases. Lexicase selection has been shown to improve performance of a GP system on a variety of problems \cite{Helmuth:2014:ieeeTEC, Helmuth:2014:GECCO, Helmuth:2013:GECCOcomp}. %Maybe take out the last reference here if need room

Implicit fitness sharing (IFS) is a modification of tournament selection designed to encourage diversity preservation in the population \cite{McKay:2000:GECCO}. IFS selection greatly rewards individuals for solving training cases that are solved by few members of the population, and gives less reward for solving cases that are solved by more of the population. Most of the problems here produce non-binary error values, for which we use the non-binary adaptation of IFS found in \cite{Krawiec:2013:EvoIASP}. As required by this method, we normalize error values to $[0, 1]$ by dividing each error by a maximum allowed error value, which differs per problem. 

\begin{table}[t]
\centering
\caption{Number of successful runs out of 100 for each setting, where ``Tourney'' is size 7 tournament selection and ``IFS'' is implicit fitness sharing with size 7 tournaments. For each problem, bold indicates significant improvement over the other two at $p < 0.05$ based on a pairwise chi-square test with Holm correction \cite{R}, or a pairwise Fisher's exact test with Holm correction if any number of successes is below 5 \cite{fmsb}.}
\label{tableResults}
\begin{tabular}{|l|rrr|}
\hline
Problem                    & Lexicase & Tourney & IFS \\
\hline
Number IO                  & \textbf{98}       & 68      & 72  \\
Small Or Large             & 5        & 3       & 3   \\
For Loop Index             & 1        & 0       & 0   \\
Compare String Lengths     & 7        & 3       & 6   \\
Double Letters             & 6        & 0       & 0   \\ 
Collatz Numbers            & 0        & 0       & 0   \\
Replace Space with Newline & \textbf{51}       & 8       & 16  \\
String Differences         & 0        & 0       & 0   \\
Even Squares               & 2        & 0       & 0   \\
Wallis Pi                  & 0        & 0       & 0   \\
String Lengths Backwards   & \textbf{66}       & 7       & 10  \\
Last Index of Zero         & \textbf{21}       & 8       & 4   \\
Vector Average             & 16       & 14      & 13  \\
Count Odds                 & \textbf{8}        & 0       & 0   \\
Mirror Image               & \textbf{78}       & 46      & 64  \\
Super Anagrams             & 0        & 0       & 0   \\
Sum of Squares             & 0        & 3       & 1   \\
Vectors Summed             & 1        & 0       & 0   \\
X-Word Lines               & \textbf{8}        & 0       & 0   \\
Pig Latin                  & 0        & 0       & 0   \\
Negative To Zero           & \textbf{45}       & 10      & 8   \\
Scrabble Score             & 2        & 0       & 0    \\
Word Stats                 & ND0      & ND0     &  NS   \\
Checksum                   & 0         & 0        & 0    \\
Digits                     & 7        & 0       & 1   \\
Grade                      & 4        & 0       & 0   \\
Median                     & 45       & 7       & 43  \\
Smallest                   & 81       & 75      & \textbf{98}  \\
Syllables                  & 18       & 1       & 7   \\
\hline
Problems Solved (UPDATE)           & 21       & 13      & 14   \\
\hline
\end{tabular}
\end{table}


Table \ref{tableResults} displays the results of our parent selection experiment. Over the 29 problems, PushGP had at least one successful run on seven more problems than IFS and 8 more than tournament selection.
(UPDATE THESE NUMBERS WITH FINAL RESULTS)
Additionally, there were 8 problems where using lexicase achieved a significantly higher number of successful runs, where IFS showed significant improvement on just one problem and tournament selection none. These results indicate the utility of lexicase selection for general program synthesis problems.



The data in Table \ref{tableResults} only reflect solution problems that generalize by achieving zero error on the unseen test set. Some problems seem to lend themselves to generalization more than others; for example, PushGP using lexicase selection found 14 programs with zero error on the training set for the Super Anagrams problem, none of which generalized to the test set. For lexicase, five problems resulted in 20 or more runs that passed the training set that did not generalize (Small Or Large,
Compare String Lengths,
Last Index of Zero,
Negative To Zero,
Median),
and five problems with between 10 and 20 runs that did not generalize (String Lengths Backwards,
Mirror Image,
Digits,
Smallest,
Super Anagrams).
These 10 problems show an important area for future study: how to evolve programs that generalize to unseen data for general program synthesis problems. Among these problems are the only five in the suite that give a correct/incorrect binary error as fitness in our implementation: Compare String Lengths, Mirror Image, Super Anagrams, Median, Smallest. This shows the difficulty of evolving general programs based entirely on correctness of output, and suggests that these problems might be better tackled if they can be transformed into problems with more informative outputs.

%Problems with >= 20 non-generalizing using lexicase:
%Small Or Large
%Compare String Lengths
%Last Index of Zero
%Negative To Zero
%Median
%
%Problems with [10, 20] non-generalizing using lexicase:
%String Lengths Backwards
%Mirror Image
%Digits
%Smallest
%Super Anagrams (none generalize)

With regards to the problems themselves, this experiment illustrates the ability of this benchmark suite to provide useful comparisons between multiple systems or parameter settings. By looking at the number of problems solved by each technique, and how often each technique showed significant improvements over the others, we can clearly see that lexicase selection increases PushGP's ability to solve general program synthesis problems compared to tournament selection and implicit fitness sharing. The main goal of a benchmark suite is to support this type of experiment. Additionally, some problems in the suite were solved frequently by each system, where others were solved infrequently or not at all. This range of difficulties allows the suite to be useful for a variety of experiments, and allows it to remain relevant as program synthesis systems improve.

Of the seven problems on which PushGP found no generalizing solution, most are not surprising in that they require extensive use of different programming constructs, the linking of many distinct steps, or a deceptive fitness space where fitness improvements do not lead toward perfect programs. The lexicase selection runs found 14 non-generalizing solutions to the Super Anagrams problem, suggesting that it may be solvable, but that issues of generalization must be addressed to reliably generate general solution. Finally, we have written solutions to each of the unsolved problems ourselves to ensure that each problem is solvable within the constraints we make on the system and instruction set.




%(Should we give the minimum size of a solution found by GP?
%probably should use simplified programs.
%gives idea of how large would need to search with something like brute-force search.)
% -- probably not enough space, though it's interesting. I looked into it, and minimum sizes tend to be between 6 and 20, though a few were higher up to 53.



\section{Conclusions}

Conclusions goes here; this is filler text. Conclusions goes here; this is filler text. Conclusions goes here; this is filler text. Conclusions goes here; this is filler text. Conclusions goes here; this is filler text. Conclusions goes here; this is filler text. Conclusions goes here; this is filler text. Conclusions goes here; this is filler text. Conclusions goes here; this is filler text. Conclusions goes here; this is filler text. Conclusions goes here; this is filler text. The end.


%ACKNOWLEDGMENTS are optional
\section{Acknowledgments}
Omitted for blind review.

%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{gpBenchmarksReferences}  % sigproc.bib is the name of the Bibliography in this case
% You must have a proper ``.bib'' file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
%APPENDICES are optional
%\balancecolumns
%\appendix
%%Appendix A
%\section{Headings in Appendices}
%The rules about hierarchical headings discussed above for
%the body of the article are different in the appendices.
%In the \textbf{appendix} environment, the command
%\textbf{section} is used to
%indicate the start of each Appendix, with alphabetic order
%designation (i.e. the first is A, the second B, etc.) and
%a title (if you include one).  So, if you need
%hierarchical structure
%\textit{within} an Appendix, start with \textbf{subsection} as the
%highest level. Here is an outline of the body of this
%document in Appendix-appropriate form:
%\subsection{Introduction}
%\subsection{The Body of the Paper}
%\subsubsection{Type Changes and  Special Characters}
%\subsubsection{Math Equations}
%\paragraph{Inline (In-text) Equations}
%\paragraph{Display Equations}
%\subsubsection{Citations}
%\subsubsection{Tables}
%\subsubsection{Figures}
%\subsubsection{Theorem-like Constructs}
%\subsubsection*{A ' for the \TeX\ Expert}
%\subsection{Conclusions}
%\subsection{Acknowledgments}
%\subsection{Additional Authors}
%This section is inserted by \LaTeX; you do not insert it.
%You just add the names and information in the
%\texttt{{\char'134}additionalauthors} command at the start
%of the document.
%\subsection{References}
%Generated by bibtex from your ~.bib file.  Run latex,
%then bibtex, then latex twice (to resolve references)
%to create the ~.bbl file.  Insert that ~.bbl file into
%the .tex source file and comment out
%the command \texttt{{\char'134}thebibliography}.
%% This next section command marks the start of
%% Appendix B, and does not continue the present hierarchy
%\section{More Help for the Hardy}
%The sig-alternate.cls file itself is chock-full of succinct
%and helpful comments.  If you consider yourself a moderately
%experienced to expert user of \LaTeX, you may find reading
%it useful but please remember not to change it.
%%\balancecolumns % GM June 2007
%% That's all folks!

\end{document}
