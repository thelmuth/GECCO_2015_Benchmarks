
%%%%%
% Some things will likely have to be cut. Here are some options. The number in [1,10] with each indicates the importance of the thing, with higher numbers being more important (and thus harder to cut).
%
% CUT 2. GP Parameters table - This takes up a lot of space. While this would be needed for exactly replicating our experiments, we could succinctly and vaguely explain the parameter ranges in text and point to the implementations for exact values.
%
% 7. Table of instruction types used with each problem - This table is huge (takes up a page). But, it adds a lot to the discussion of our implementation recommendations.
%
% PARED 3. Methods section - We might need to make this as brief as possible, with pointers to other papers (like our WC paper) for more details. 
%
% 5. Parts of the experiments section - This is currently pretty long considering it's not the focus of the paper.
%
% MOSTLY CUT 1-4. Some citations - Some citations probably aren't necessary. I've marked a few in the text, especially with regards to lexicase selection, where I've cited multiple papers where a single citation might suffice. Also when citing PushGP. Also maybe the fmsb package citation for R.
%
% 8. Discussion of generalization in Experiments - this seems useful, but might be cutable
%
%%%%%

\documentclass{sig-alternate}

\usepackage{tabulary}
%\usepackage[hyphens]{url}
\usepackage{rotating}
\usepackage{underscore}

\usepackage{booktabs}
\usepackage[table]{xcolor}
\definecolor{Gray}{gray}{0.9}

\graphicspath{{./Figures/}}

\begin{document}
%
% --- Author Metadata here ---

% This is from ACM rights review
\setcopyright{acmcopyright}
\conferenceinfo{GECCO '15,}{July 11 - 15, 2015, Madrid, Spain}
\isbn{978-1-4503-3472-3/15/07}\acmPrice{\$15.00}
\doi{http://dx.doi.org/10.1145/2739480.2754769}

%\CopyrightYear{2015}
%\crdata{TBA}
\clubpenalty=10000
\widowpenalty = 10000
% --- End of Author Metadata ---

%      IntroProg Benchmark Suite for General Program Synthesis
\title{General Program Synthesis Benchmark Suite}

\numberofauthors{2} 

\author{
% 1st. author
\alignauthor
Thomas Helmuth\\
       \affaddr{Computer Science}\\
       \affaddr{University of Massachusetts}\\
       \affaddr{Amherst, MA 01003}\\
       \email{thelmuth@cs.umass.edu}
% 2nd. author
\alignauthor
Lee Spector\\
       \affaddr{Cognitive Science}\\
       \affaddr{Hampshire College}\\
       \affaddr{Amherst, MA 01002}\\
       \email{lspector@hampshire.edu}
}

\maketitle

\begin{abstract}
Recent interest in the development and use of non-trivial benchmark problems for genetic programming research has highlighted the scarcity of general program synthesis (also called ``traditional programming'') benchmark problems. We present a suite of $29$ general program synthesis benchmark problems systematically selected from sources of introductory computer science programming problems. This suite is suitable for experiments with any program synthesis system driven by input/output examples. We present results from illustrative experiments using our reference implementation of the problems in the PushGP genetic programming system. The results show that the problems in the suite vary in difficulty and can be useful for assessing the capabilities of a program synthesis system.
\end{abstract}

\category{I.2.2}{Artificial Intelligence}{Automatic Programming}[Program synthesis]

%% A category with the (minimum) three required fields
%\category{H.4}{Information Systems Applications}{Miscellaneous}
%%A category including the fourth, optional field follows...
%\category{D.2.8}{Software Engineering}{Metrics}[complexity measures, performance measures]

%\terms{Theory}

\keywords{program synthesis; genetic programming; benchmarks}

\section{Introduction}

Several genetic programming (GP) researchers have highlighted the need for better benchmark problems to guide research in the field \cite{McDermott:2012:GECCO, White:2013:BGB:2441218.2441242, Woodward:2014:GECCOcomp}. While benchmarks have been proposed, few are for general programming problems (also called ``traditional'' or ``algorithmic'' programming problems) even though this category received the second highest level of interest in a recent community survey about the need for benchmarks \cite{White:2013:BGB:2441218.2441242}. 

Automating human programming has long been a goal of GP, as articulated for example in Koza's first book \cite{koza:book}. The purpose of a general program synthesis benchmark is to help researchers assess the ability of a system to automate human programming. Such problems should require a range of programming techniques including the use of control flow, modularity, and large, diverse instruction sets covering multiple data types and data structures. Also, minimal sizes for solution programs should cover a range beyond what could be found using brute-force search. This contrasts with most existing benchmark problems used in GP and other program synthesis fields \cite{hofmann2009unifying}, which prescribe small, domain-specific instruction sets and assess a system's abilities only on a narrow range of programming techniques.

In this paper we present a suite of $29$ general program synthesis benchmark problems, systematically selected from sources of introductory computer science programming problems. We present each problem's specifications in the form of input/output examples, making them suitable to a wide range of program synthesis techniques, including GP. While the problems are not particularly challenging for skilled human programmers, they are reasonably challenging for beginners and many are arguably too difficult for existing program synthesis systems, including GP. As textbook problems, they are not likely representative of real general program synthesis applications, yet they should prove useful for assessing progress toward this goal.
% These benchmark problems should prove useful for assessing progress toward the goal of developing general program synthesis systems.

%In the sections below we first discuss issues related to the use of our benchmarks to assess and compare systems. We then describe the criteria used to select problems and each of the $29$ problems that we selected. Next, we present example system-specific parameters for our reference implementation in the PushGP system \cite{spector:2002:GPEM, 1068292}, followed by the results of an illustrative experiment.


%- cite \cite{Woodward:2014:GECCOcomp} in the discussion of GP benchmarks
%- One of the main points of the \cite{Woodward:2014:GECCOcomp} paper is that benchmark problems should come from a distribution relevant to the class of problems you are interested in solving. Our class of problems is general programming problems. Since we (a) don't know how to sample from this class of problems, and (b) don't know if we'd be able to solve that difficult of problem anyway, we instead are providing a set of intro CS problems. By giving a large range of problems, we do get some sampling of the space. And by using intro CS problems, we are building toward larger general programming problems---a first step.


\section{Benchmark-based comparisons}


We designate the solution of a general program synthesis problem as a program that perfectly maps inputs to the correct outputs. While one might argue that human-written software is often useful even if it has known bugs, the goal here is to pass all input/output tests. Therefore, we are not interested in programs that are only approximately correct, as might be appropriate in the context of other problems for which GP is used, such as symbolic regression. We recommend measuring performance on the problems presented here primarily in terms of success rates, quantifying how often a stochastic algorithm finds a successful program across a set of runs\footnote{For deterministic synthesis algorithms other measures must be used, such as whether a correct program is found within a set period of time.}. A more thorough argument for assessment in terms of success rates can be found in \cite{Helmuth:2014:GECCO}.
Furthermore, in order to be considered successful, a program must not only achieve zero error on all of the example data used to train the program (the ``training set''), but also on a set of withheld generalization data (the ``test set''). 
%Since we do not want to require formal specifications for the problem, this test set is the best way to test whether a program actually solves the problem or instead memorizes the training set.


%Statistical procedure -- maybe leave out? Would talk about chi-square tests and Fisher's exact test. (leaving out for now)

When using this benchmark suite to compare different settings within one system, we recommend limiting computation with a budget based on the maximum number of program evaluations allowed in a run. This ensures that the methods perform similar computational work. That said, it may nonetheless be difficult to justify fine-grained numerical comparisons among diverse techniques on these problems, as they may involve qualitatively different kinds of costs and each may be parameterized in radically different ways. In many cases, the most interesting question to ask vis-a-vis a particular system on a particular problem may just be whether the system can solve the problem at all, and if so,  whether it can solve it reasonably reliably. Nevertheless, we aim here to describe specifications that will allow for as much cross-system comparability as possible. % A lot of this paragraph is copied from a Lee email; it sounded good, so I kept it with minor editing.


\section{Problem selection criteria} \label{requirements}

In this section we describe the criteria we used when selecting problems for the benchmark suite. Several of our criteria overlap with those described in the GP benchmarks papers \cite{McDermott:2012:GECCO, White:2013:BGB:2441218.2441242}, such as being varied, relevant, realistically difficult, representation-independent, and precisely defined. 
%Other proposed requirements have less relevance to this set of problems because of the general program synthesis domain we target.

This benchmark suite is designed for systems that use example inputs and their corresponding outputs as the specifications for desired programs. In the context of GP, we call the input/output pairs \textit{test cases} for the problem. Thus, a problem must be defined on a range of inputs that have known correct outputs; it cannot simply specify the calculation of a single value. For example, a problem that requires the program to calculate the number of prime numbers less than 1000 would not qualify, since it only has one answer; but, a similar problem that requires the program to calculate the number of prime numbers less than an input integer $n$ would meet this requirement, since we could then provide example inputs for $n$ and their corresponding outputs. This requirement also ensures that test cases can be generated to fill the training and test set, as required to test generalization of successful programs.

Problems in the suite should present challenges typical of real programming tasks. 
%The goal of a benchmark problem is to measure the characteristics of a system on a problem that mimics some aspects of the real applications on which it is expected to function. 
This criterion leads us to choose problems that call for a range of programming constructs and data types. The problems should require a variety of sizes and shapes for solution programs, not just artificially small programs. 

The benchmarks should not be biased toward a particular method of synthesis; it should be possible to attempt to solve them using various GP systems as well as analytic and search-based program synthesis systems. Since systems generate programs in a variety of languages, we avoid problems that require a specific language feature or non-standard data type (such as Java objects).

We take our problems from pre-existing sources of introductory programming problems. From each source, we include all problems that meet the criteria described above, aiming to avoid biasing the selection of problems. We rejected problems from other sources that did not meet our criteria, such as the inductive programming benchmark repository\footnote{\url{http://www.inductive-programming.org/repository.html}}, other program synthesis and inductive programming papers, and programming competitions.

%[BELONG ELSEWHERE? BETTER TRANSITION? OR JUST REMOVE?]
%For a synthesis system to be applicable to the problems in this suite, it must take input/output examples as program specifications. It must be able to produce programs that manipulate the data types necessary to solve the problems, which includes the ability to print outputs and return functional results. Any synthesis system that meets these requirements may be applied to these problems.


\section{Problem Descriptions} \label{descriptionsSection}
% Other section title options: Problems or The Problems or The Benchmark Problems

We used two sources for problems: iJava \cite{iJava}, an interactive textbook for introductory computer science, and IntroClass \cite{ManyBugsAndIntroClass, Brun13TRgptest}, a set of problems originally used as benchmarks for automatic program repair. Below we describe each of these sources in further detail and present our natural language description of each problem, summarized from the original source. All problems use functional arguments as inputs besides one that requires reading input from a file. Some problems require programs to return functional outputs, where others require the program to print results.

\subsection{iJava}

%In this section, we will describe the problems from iJava \cite{iJava, Moll:2011:IOI:1968521.1968535}. 

iJava is an interactive introductory computer science textbook that contains a number of automatically graded programming problems \cite{iJava}. %, Moll:2011:IOI:1968521.1968535}.
 Many of its problems are graded by testing programs against a range of inputs, making them easy to convert into benchmark problems.


Some sets of problems in iJava meet our criteria but test similar programming techniques; for these sets, we chose one representative problem from the group, ensuring a reasonable distribution of problem requirements. Along with each problem name and description, we provide the question or project number associated with the problem in iJava 3.1.

\begin{enumerate}
\item
\textbf{Number IO (Q 3.5.1)}
Given an integer and a float, print their sum.

\item
\textbf{Small or Large (Q 4.6.3)}
Given an integer $n$, print ``small'' if $n < 1000$ and ``large'' if $n \ge 2000$ (and nothing if $1000 \le n < 2000$).

\item
\textbf{For Loop Index (Q 4.11.7)}
Given 3 integer inputs $start, end,$ and $step$, print the integers in the sequence
\begin{align*}
n_0 &= start \\
n_i &= n_{i-1} + step
\end{align*}
for each $n_i < end$, each on their own line.

\item
\textbf{Compare String Lengths (Q 4.11.13)}
Given three strings $n1$, $n2$, and $n3$, return true if $length(n1) < length(n2) < length(n3)$, and false otherwise.

\item
\textbf{Double Letters (P 4.1)}
Given a string, print the string, doubling every letter character, and tripling every exclamation point. All other non-alphabetic and non-exclamation characters should be printed a single time each.

\item
\textbf{Collatz Numbers (P 4.2)}
Given an integer, find the number of terms in the Collatz (hailstone) sequence starting from that integer.

\item
\textbf{Replace Space with Newline (P 4.3)}
Given a string input, print the string, replacing spaces with newlines. Also, return the integer count of the non-whitespace characters. The input string will not have tabs or newlines.

\item
\textbf{String Differences (P 4.4)}
Given 2 strings (without whitespace) as input, find the indices at which the strings have different characters, stopping at the end of the shorter one. For each such index, print a line containing the index as well as the character in each string. For example, if the strings are ``dealer'' and ``dollars'', the program should print:
\texttt{\\*
\hspace*{1cm}1 e o \\*
\hspace*{1cm}2 a l \\*
\hspace*{1cm}4 e a
}

\item
\textbf{Even Squares (Q 5.4.1)}
Given an integer $n$, print all of the positive even perfect squares less than $n$ on separate lines.

\item
\textbf{Wallis Pi (P 6.4))}
John Wallis gave the following infinite product that converges to $\pi/4$:
\[
\frac{2}{3}\times \frac{4}{3}\times \frac{4}{5}\times \frac{6}{5}\times \frac{6}{7}\times \frac{8}{7}\times \frac{8}{9}\times \frac{10}{9} \times ...
\]
Given an integer input $n$, compute an approximation of this product out to $n$ terms. Results are rounded to 5 decimal places.

\item
\textbf{String Lengths Backwards (Q 7.2.5)}
Given a vector of strings, print the length of each string in the vector starting with the last and ending with the first.

\item
\textbf{Last Index of Zero (Q 7.7.8)}
Given a vector of integers, at least one of which is 0, return the index of the last occurrence of 0 in the vector.

\item
\textbf{Vector Average (Q 7.7.11)}
Given a vector of floats, return the average of those floats. Results are rounded to 4 decimal places.

\item
\textbf{Count Odds (Q 7.7.12)}
Given a vector of integers, return the number of integers that are odd, without use of a specific \texttt{even} or \texttt{odd} instruction (but allowing instructions such as \texttt{mod} and \texttt{quotient}).

\item
\textbf{Mirror Image (Q 7.7.15)}
Given two vectors of integers, return \texttt{true} if one vector is the reverse of the other, and \texttt{false} otherwise.

\item
\textbf{Super Anagrams (P 7.3)}
Given strings $x$ and $y$ of lowercase letters, return true if $y$ is a super anagram of $x$, which is the case if every character in $x$ is in $y$. To be true, $y$ may contain extra characters, but must have at least as many copies of each character as $x$ does.

\item
\textbf{Sum of Squares (Q 8.5.4)}
Given integer $n$, return the sum of squaring each integer in the range $[1, n]$.

\item
\textbf{Vectors Summed (Q 8.7.6)}
Given two equal-sized vectors of integers, return a vector of integers that contains the sum of the input vectors at each index.

\item
\textbf{X-Word Lines (P 8.1)}
Given an integer $X$  and a string that can contain spaces and newlines, print the string with exactly $X$ words per line. The last line may have fewer than $X$ words.

\item
\textbf{Pig Latin (P 8.2)}
Given a string containing lowercase words separated by single spaces, print the string with each word translated to pig Latin. Specifically, if a word starts with a vowel, it should have ``ay'' added to its end; otherwise, the first letter is moved to the end of the word, followed by ``ay''.

\item
\textbf{Negative To Zero (Q 9.6.8)}
Given a vector of integers, return the vector where all negative integers have been replaced by 0.

\item
\textbf{Scrabble Score (P 10.1)}
Given a string of visible ASCII characters, return the Scrabble score for that string. Each letter has a corresponding value according to normal Scrabble rules, and non-letter characters are worth zero.

\item
\textbf{Word Stats (P 10.5)}
Given a file, print the number of words containing $n$ characters for $n$ from 1 to the length of the longest word, in the format:
\texttt{ \\
\hspace*{1cm}words of length 1: 12 \\
\hspace*{1cm}words of length 2: 3 \\
\hspace*{1cm}words of length 3: 0 \\
\hspace*{1cm}words of length 4: 5 \\
\hspace*{1cm}... \\
}
\noindent At the end of the output, print a line that gives the number of sentences and line that gives the average sentence length using the form:
\texttt{ \\
\hspace*{1cm}number of sentences: 4 \\
\hspace*{1cm}average sentence length: 7.452423455 \\
}
\noindent A word is any string of consecutive non-whitespace characters (including sentence terminators). Every file will contain at least one sentence terminator (period, exclamation point, or question mark). The average sentence length is the number of words in the file divided by the number of sentence terminator characters.

\end{enumerate}

\subsection{IntroClass}

%In this section, we will describe the problems from the IntroClass dataset \cite{ManyBugsAndIntroClass, Brun13TRgptest}. 

The set of 6 problems in the IntroClass dataset \cite{ManyBugsAndIntroClass, Brun13TRgptest} was designed for the purpose of benchmarking automatic software defect repair systems. As such, the authors of this dataset provide a number of buggy programs written by students trying to solve each problem, taken from students in an introductory computer science class. For the purposes of general program synthesis from scratch, we will use the problems themselves but not the accompanying buggy programs. 
%Since these problems were designed for automatic defect repair, they all can be tested on a range of inputs, and require outputs to be printed.
%Each of these problems can be tested on a range of inputs, and each requires outputs to be printed.

\begin{enumerate}
\setcounter{enumi}{23}

\item
\textbf{Checksum}
Given a string, convert each character in the string into its integer ASCII value, sum them, take the sum modulo 64, add the integer value of the space character, and then convert that integer back into its corresponding character (the checksum character). The program must print \texttt{Check sum is X}, where $X$ is replaced by the correct checksum character.

\item
\textbf{Digits}
Given an integer, print that integer's digits each on their own line starting with the least significant digit. A negative integer should have the negative sign printed before the most significant digit.

\item
\textbf{Grade}
Given 5 integers, the first four represent the lower numeric thresholds for achieving an A, B, C, and D, and will be distinct and in descending order. The fifth represents the student's numeric grade. The program must print \texttt{Student has a X grade.}, where $X$ is A, B, C, D, or F depending on the thresholds and the numeric grade.

\item
\textbf{Median}
Given 3 integers, print their median.

\item
\textbf{Smallest}
Given 4 integers, print the smallest of them.

\item
\textbf{Syllables}
Given a string containing symbols, spaces, digits, and lowercase letters, count the number of occurrences of vowels (a, e, i, o, u, y) in the string and print that number as $X$ in \texttt{The number of syllables is X}.

\end{enumerate}

\section{Synthesis Specifications} \label{synthProbSpec}
% Other title options: Synthesis Parameters, Data and Instructions


%The natural language descriptions of the benchmark problems in Section \ref{descriptionsSection} contain insufficient details to implement specifications for each desired program in a program synthesis system. In this section we discuss issues related to defining problems so that they are interpretable by program synthesis systems. These specifications will allow the benchmark problems to be implemented in a variety of systems and should be technique-independent, while ensuring that different implementations are solving the ``same problem''.

The natural language descriptions of the problems in Section \ref{descriptionsSection} do not provide all of the information needed to apply program synthesis systems to the problems. Here we provide the needed additional information, aiming to do so in a technique-independent and system-independent way.

\begin{table*}[t]
\centering
\caption{For each problem, the types of the inputs and outputs, and the limits imposed on the inputs. Any printed outputs should be printed by the program to standard output. The columns Train and Test indicate the recommended sizes of the training set and test set respectively.}
\label{testCasesTable}
%{\renewcommand{\arraystretch}{1}%
\rowcolors{3}{Gray}{white}
\begin{tabular}{>{\raggedright}p{3.5cm}  >{\raggedright}p{7.4cm} >{\raggedright}p{2.3cm} rr}
\toprule
\textbf{Name} & \textbf{Inputs} & \textbf{Outputs} & \textbf{Train} & \textbf{Test} \\
\midrule
Number IO & integer in $[-100, 100]$, float in $[-100.0, 100.0]$ & printed float & 25 & 1000 \\
%\hline
Small Or Large & integer in $[-10000, 10000]$ & printed string & 100 & 1000 \\
%\hline
For Loop Index & integers \texttt{start} and \texttt{end} in $[-500, 500]$, \texttt{step} in $[1, 10]$ & printed integers & 100 & 1000 \\
%\hline
Compare String Lengths & 3 strings of length $[0, 49]$ & boolean & 100 & 1000 \\
%\hline
Double Letters & string of length $[0, 20]$ & printed string & 100 & 1000 \\
%\hline
Collatz Numbers & integer in $[1, 10000]$ & integer & 200 & 2000 \\
%\hline
Replace Space with Newline & string of length $[0, 20]$ & printed string, integer & 100 & 1000 \\
%\hline
String Differences & 2 strings of length $[0, 10]$ & printed string & 200 & 2000 \\
%\hline
Even Squares & integer in $[1, 9999]$ & printed string & 100 & 1000 \\
%\hline
Wallis Pi & integer in $[1, 200]$ & float & 150 & 50 \\
%\hline
String Lengths Backwards & vector of length $[0, 50]$ of strings of length $[0, 50]$ & printed string & 100 & 1000 \\
%\hline
Last Index of Zero & vector of integers of length $[1, 50]$ with each integer in $[-50, 50]$ & integer & 150 & 1000 \\
%\hline
Vector Average & vector of floats of length $[1,50]$ with each float in $[-1000.0, 1000.0]$ & float & 100 & 1000 \\
%\hline
Count Odds & vector of integers of length $[0,50]$ with each integer in $[-1000, 1000]$ & integer & 200 & 2000 \\
%\hline
Mirror Image & 2 vectors of integers of length $[0,50]$ with each integer in $[-1000, 1000]$ & boolean & 100 & 1000 \\
%\hline
Super Anagrams & 2 strings of length $[0, 20]$ & boolean & 200 & 2000 \\
%\hline
Sum of Squares & integer in $[1, 100]$ & integer & 50 & 50 \\
%\hline
Vectors Summed & 2 vectors of integers of length $[0,50]$ with each integer in $[-1000, 1000]$ & vector of integers & 150 & 1500 \\
%\hline
X-Word Lines & integer in $[1, 10]$, string of length $[0, 100]$ & printed string & 150 & 2000 \\
%\hline
Pig Latin & string of length $[0, 50]$ & printed string & 200 & 1000 \\
%\hline
Negative To Zero & vector of integers of length $[0,50]$ with each integer in $[-1000, 1000]$ & vector of integers & 200 & 2000 \\
%\hline
Scrabble Score & string of length $[0, 20]$ & integer & 200 & 1000 \\
%\hline
Word Stats & file containing $[1, 100]$ chars & printed string & 100 & 1000 \\
%\hline
Checksum & string of length $[0, 50]$ & printed string & 100 & 1000 \\
%\hline
Digits & integer in $[-9999999999, 9999999999]$ & printed integers & 100 & 1000 \\
%\hline
Grade & 5 integers in $[0, 100]$ & printed string & 200 & 2000 \\
%\hline
Median & 3 integers in $[-100, 100]$ & printed integer & 100 & 1000 \\
%\hline
Smallest & 4 integers in $[-100, 100]$ & printed integer & 100 & 1000 \\
%\hline
Syllables & string of length $[0, 20]$ & printed string & 100 & 1000\\
\bottomrule
\end{tabular}
\end{table*}

%Table \ref{testCasesTable} presents information related to the sets of training and test data for each problem. These recommendations, like the rest in this section, are not set in stone; instead, they present guidelines that should be followed where possible. Adhering to these guidelines closely will create results with more legitimate comparability to the results presented here. The table describes the data types of the inputs and outputs and gives reasonable ranges for program inputs. Note that some problems specify that outputs are printed to standard output, a requirement exhibited often in human-written code but rarely seen in automatic program synthesis previously. These problems explicitly required the printing of results in their original sources.

Table \ref{testCasesTable} presents recommendations regarding training and test data for each problem. While these are merely guidelines, and there may be good reasons to diverge from them when using different techniques or systems, adhering to these guidelines will clarify comparisons among techniques and systems. The table describes the data types of the inputs and outputs and gives reasonable ranges for program inputs. 

We also provide recommendations for numbers of cases to use in the training and test sets in Table \ref{testCasesTable}. For most problems, we recommend between 100 and 200 training cases, depending on the difficulty of the problem as well as the dimensionality of the input space. A few problems use fewer, either because they have limited input spaces or are simple enough to solve with fewer cases. We usually recommend using a test set ten times as large as the training set; again, there are exceptions for problems with limited input spaces. The method of producing the training and test cases is system-specific; we recommend a combination of hand-chosen edge cases with randomly generated cases, and will describe our method in more detail in Section \ref{systemParamsSection}.

% Table 2 prior location

The question of which instructions to make available for a synthesis system to use for each problem is a complex one. It is important to not cherry pick a small set of instructions that are known to be sufficient to solve a problem; such a selection may be difficult for a real-world problem, where it might not be clear which instructions will be useful. On the other hand, using all available instructions for every problem expands the search space and may make problems more difficult than necessary. We recommend a compromise between these approaches
% by first determining what data types are required for each instruction in the instruction set, and then deciding which data types could be useful in solving each problem and using the relevant instructions. 
in which one first determines which data types are likely to be useful for solving the problem and then uses all instructions that operate on those data types.
For example, an instruction that compares the equality of two integers and returns a boolean would be included if the problem could potentially make use of integers and booleans. 
By specifying only the data type requirements for a problem, we can limit the number of instructions without cherry picking. 


\section{System-Specifc Parameters} \label{systemParamsSection}

Whereas Section \ref{synthProbSpec} gave technique-independent recommendations for specifying the benchmark problems for a synthesis system, this section will give more detail about the system-specific parameters and decisions that must be made in order to implement these problems in a given program synthesis system. Here we will focus on our implementation in the PushGP genetic programming system, but we emphasize that this is just one possible approach and one possible implementation, and that the problems here could be used in any system that meets the requirements in Section \ref{requirements}.

PushGP evolves programs in Push, a stack-based programming language designed specifically for GP \cite{spector:2002:GPEM, 1068292}. % Maybe remove one or two of these citations?
%PushGP has many features useful for general program synthesis, such as supporting multiple data types, control flow, and the use of input/output examples as specifications. 
The reference implementation of our problems in PushGP can be found on GitHub\footnote{\url{http://thelmuth.github.io/GECCO_2015_Benchmarks_Materials/}}. In the rest of this section, we will describe some of the major decisions necessary for implementing these benchmark problems in this environment.
% As we do not have space to discuss every parameter and implementation choice, the technical report accompanying this paper supplements the information presented here \cite{helmuth:umass:tr}.

\subsection{Training and Test Data}

When generating training and test data, we use a combination of hand-picked edge cases that remain constant across runs and randomly generated inputs that vary across runs. For each problem, we specify one or more ``data domains'' \cite{Helmuth:2014:GECCO}, which consist of either a set of hard-coded inputs or a random input generator, as well as the number of training and test cases that should come from each domain. % Details on using data domains can be found in \cite{Helmuth:2014:GECCO}, and our technical report gives our choices for data domains for each problem \cite{helmuth:umass:tr}.


%%% start copying from WC paper

In order to facilitate the creation of training and test data, we designed a general system for automatic data generation based on data domains. A ``data domain'' $D$ is a set of program inputs described by either a list of inputs or a random input generator function. The sets $\{$\texttt{"hi"}, \texttt{"hello"}, \texttt{"howdy"}, \texttt{"hey"}$\}$ and $\{s | ``zoo" \text{ is a substring of } s; \text{len}(s) <= 100] \}$ are examples of data domains, where the former is an enumerated set of four inputs and the latter is a large set containing all strings of length less than or equal to 100 that contain the substring \texttt{"zoo"}. Along with each data domain $D$, the user must provide the integers $train(D)$ and $test(D)$ that indicate the number of training and test cases respectively to generate from $D$.

To generate training and test data from a set of data domains $\{D_1, D_2, ..., D_n \}$, we simply take each domain and create the required number of cases. If the domain $D_i$ is an enumerated list of inputs, we select $train(D_i)$ and $test(D_i)$ of them at random, without replacement within the training cases or test cases. If the domain is described by a random input generator, we run it $train(D_i)$ and $test(D_i)$ times (with replacement) to create the data. This automatic data generation system allows for the generation of training and test cases for a wide range of problems.

%%% end copying from WC paper

Tables \ref{datadomains1}, \ref{datadomains2}, and \ref{datadomains3} present detailed descriptions of the data domains we used to generate training and test data for each benchmark problem. The table has two types of data domains: hard coded lists of inputs (HC) and random input generators (RNGs). For HC data domains, we give the list of inputs; for RNGs, we describe the generator. Unless stated otherwise, RNGs have the following properties: ranges for inputs are given in Table \ref{testCasesTable}, unless stated otherwise. For integer and float RNGs, inputs are sampled uniformly across the given range; for string RNGs, lengths are sampled uniformly between 1 and the max length given in Table \ref{testCasesTable}, and characters are distributed uniformly across visible ASCII characters along with space, newline, and tab. If a HC domain is specified by a range such as [40, 50], it includes every integer in the range inclusive. Finally, for HC string inputs, we use \texttt{"\textvisiblespace"} for the space character, \texttt{"\textbackslash t"} for tab, and \texttt{"\textbackslash n"} for newline.

%%% Start info about our specific data domains

\begin{table*}
\centering
\caption{Data domains for each benchmark problem (part 1).}
\label{datadomains1}
\rowcolors{3}{Gray}{white}
\begin{tabular}{>{\raggedright}p{3.5cm} l >{\raggedright}p{9.8cm} rr}
\toprule
\textbf{Name} & \textbf{Type} & \textbf{Domain} & \textbf{Train} & \textbf{Test} \\
\midrule
Number IO & RNG & integer, float & 25 & 1000 \tabularnewline
%\midrule
Small Or Large & HC & -10000, 0, 980, 1020, 1980, 2020, 10000, [995, 1004], [1995, 2004] & 27 & 0 \tabularnewline
%\rowcolor{Gray}
 & HC & integers in ranges [980, 1019] and [1980, 2019] & 0 & 80 \tabularnewline
 & RNG & integer & 73 & 920 \tabularnewline
%\midrule
For Loop Index & RNG & integers: $\texttt{start} < 0 < \texttt{end}$, $ \texttt{start} + (20 \times \texttt{step}) + 1 > \texttt{end}$ & 10 & 100 \tabularnewline
 & RNG & integers: $\texttt{start} < \texttt{end}$, $ \texttt{start} + (20 \times \texttt{step}) + 1 > \texttt{end}$ & 90 & 900 \tabularnewline
Compare String Lengths & HC & triplet \texttt{("", "", "")} & 1 & 0 \tabularnewline
 & HC & all permutations of \texttt{("", "a", "bc")} & 6 & 0 \tabularnewline
 & RNG & all permutations of 2 empty strings and a string (repeated twice) & 6 & 0 \tabularnewline
 & RNG & all permutations of 2 copies of a string and another string (repeated 3 times) & 9 & 0 \tabularnewline
 & RNG & random string repeated 3 times & 3 & 100 \tabularnewline
 & RNG & 3 strings in sorted length order & 25 & 200 \tabularnewline
 & RNG & 3 strings & 50 & 700 \tabularnewline
Double Letters & HC & \texttt{"", "A", "!", "\textvisiblespace", "*", "\textbackslash t", "\textbackslash n", "B\textbackslash n", "\textbackslash n\textbackslash n", "CD", "ef", "!!", "q!", "!R", "!\#", "@!", "!F!", "T\$L", "4ps", "q\textbackslash t ", "!!!", "i:!i:!i:!i:!i", "88888888888888888888", "\textvisiblespace\textvisiblespace\textvisiblespace\textvisiblespace \textvisiblespace\textvisiblespace\textvisiblespace\textvisiblespace \textvisiblespace\textvisiblespace\textvisiblespace\textvisiblespace \textvisiblespace\textvisiblespace\textvisiblespace\textvisiblespace \textvisiblespace\textvisiblespace\textvisiblespace\textvisiblespace", "ssssssssssssssssssss", "!!!!!!!!!!!!!!!!!!!!", "Ha\textvisiblespace Ha\textvisiblespace Ha\textvisiblespace Ha\textvisiblespace Ha\textvisiblespace Ha\textvisiblespace Ha", "x\textbackslash ny!x\textbackslash ny!x\textbackslash ny!x\textbackslash ny!x\textbackslash ny!", "1!1!1!1!1!1!1!1!1!1!", "G5G5G5G5G5G5G5G5G5G5", ">_=]>_=]>_=]>_=]>_=]", "k!!k!!k!!k!!k!!k!!k!"} & 32 & 0 \tabularnewline
 & RNG & string & 68 & 1000 \tabularnewline
Collatz Numbers & HC & 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 6171, 6943, 7963, 9257, 9999, 10000 & 16 & 0 \tabularnewline
 & RNG & integer & 184 & 2000 \tabularnewline
Replace Space With Newline & HC & \texttt{"", "A", "*", "\textvisiblespace ", "s", "B\textvisiblespace ", "\textvisiblespace \textvisiblespace ", "\textvisiblespace D", "ef", "!!", "\textvisiblespace F\textvisiblespace ", "T\textvisiblespace L", "4ps", "q\textvisiblespace \textvisiblespace ", "\textvisiblespace \textvisiblespace \textvisiblespace ", "\textvisiblespace \textvisiblespace e", "hi\textvisiblespace ", "\textvisiblespace \textvisiblespace \$\textvisiblespace \textvisiblespace ", "\textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace 9", "i\textvisiblespace !i\textvisiblespace !i\textvisiblespace !i\textvisiblespace !i", "88888888888888888888", "\textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace \textvisiblespace ", "ssssssssssssssssssss", "1\textvisiblespace 1\textvisiblespace 1\textvisiblespace 1\textvisiblespace 1\textvisiblespace 1\textvisiblespace 1\textvisiblespace 1\textvisiblespace 1\textvisiblespace 1\textvisiblespace ", "\textvisiblespace v\textvisiblespace v\textvisiblespace v\textvisiblespace v\textvisiblespace v\textvisiblespace v\textvisiblespace v\textvisiblespace v\textvisiblespace v\textvisiblespace v", "Ha\textvisiblespace Ha\textvisiblespace Ha\textvisiblespace Ha\textvisiblespace Ha\textvisiblespace Ha\textvisiblespace Ha", "x\textvisiblespace y!x\textvisiblespace y!x\textvisiblespace y!x\textvisiblespace y!x\textvisiblespace y!", "G5G5G5G5G5G5G5G5G5G5", ">_=]>_=]>_=]>_=]>_=]", "\textasciicircum _\textasciicircum \textvisiblespace \textasciicircum _\textasciicircum \textvisiblespace \textasciicircum _\textasciicircum \textvisiblespace \textasciicircum _\textasciicircum \textvisiblespace \textasciicircum _\textasciicircum \textvisiblespace "} & 30 & 0 \tabularnewline
 & RNG & string (with \texttt{\textvisiblespace} as 20\% of characters) & 70 & 1000 \tabularnewline
String Differences & HC & pairs of strings: \texttt{("" ""), ("" "hi"), ("ThereWorld" ""), ("A" "A"), ("B" "C"), ("\&" "\#"), ("4" "456789"), ("rat" "hat"), ("new" "net"), ("big" "bag"), ("STOP" "SIGN"), ("abcde" "a"), ("abcde" "abcde"), ("abcde" "edcba"), ("2n" "nn"), ("hi" "zipper"), ("dealer" "dollars"), ("nacho" "cheese"), ("loud" "louder"), ("qwertyuiop" "asdfghjkl;"), ("LALALALALA" "LLLLLLLLLL"), ("!!!!!!" ".?."), ("9r2334" "9223d4r"), ("WellWell" "wellwell"), ("TakeThat!" "TAKETHAT!!"), ("CHOCOLATE\textasciicircum " "CHOCOLATE\textasciicircum "), ("ssssssssss" "\~{}\~{}\~{}\~{}\~{}\~{}\~{}\~{}\~{}\~{}"), (">_=]>_=]>_" "q_q_q_q_q_"), ("()()()()()" "pp)pp)pp)p"), ("HaHaHaHaHa" "HiHiHiHiHi")} & 30 & 0 \tabularnewline
 & RNG & pair of strings, length $> 1$ & 170 & 0 \tabularnewline
 & RNG & pair of strings & 0 & 2000 \tabularnewline
Even Squares & HC & 1, 2, 3, 4, 5, 6, 15, 16, 17, 18, 36, 37, 64, 65, 9600, 9700, 9999 & 17 & 0 \tabularnewline
 & RNG & integer & 83 & 1000 \tabularnewline
Wallis Pi & HC & 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 198, 199, 200 & 15 & 0 \tabularnewline
 & RNG & integer & 135 & 50 \tabularnewline
String Lengths Backwards & HC & vector of strings: \texttt{[], [""], ["" ""], ["" "" ""], ["" "" "" "" "" "" "" "" "" ""], ["abcde"], ["1"], ["abc" "hi\textvisiblespace there"], ["!@\#" "\textbackslash n\textbackslash n\textbackslash t\textbackslash t" "5552\textbackslash na\textvisiblespace r"], ["tt" "333" "1" "ccc"]} & 10 & 0 \tabularnewline
 & RNG & vector of strings & 90 & 1000 \tabularnewline
\bottomrule
\end{tabular}
\end{table*}

\begin{table*}
\centering
\caption{Data domains for each benchmark problem (part 2).}
\label{datadomains2}
\rowcolors{3}{Gray}{white}
\begin{tabular}{>{\raggedright}p{3.5cm} l >{\raggedright}p{9.8cm} rr}
\toprule
\textbf{Name} & \textbf{Type} & \textbf{Domain} & \textbf{Train} & \textbf{Test} \\
\midrule
Last Index of Zero & HC & vector of integers: \texttt{[0 1], [1 0], [7 0], [0 8], [0 -1], [-1 0], [-7 0], [0 -8]} & 8 & 0 \tabularnewline
 & HC & every vector of zeros of length between 1 and 50 & 30 & 20 \tabularnewline
 & HC & all permutations of vector \texttt{[0 5 -8 9]} & 20 & 4 \tabularnewline
 & HC & all permutations of vector \texttt{[0 0 -8 9]} & 10 & 2 \tabularnewline
 & HC & all permutations of vector \texttt{[0 0 0 9]} & 4 & 0 \tabularnewline
 & RNG & vector of integers with at least one 0 & 78 & 974 \tabularnewline
Vector Average & HC & vector of floats: \texttt{[0.0], [100.0], [-100.0], [2.0 129.0], [0.12345 -4.678], [999.99 74.113]} & 6 & 0 \tabularnewline
 & RNG & length 50 vector of floats & 4 & 50 \tabularnewline
 & RNG & vector of floats & 90 & 950 \tabularnewline
Count Odds & HC & vector of integers: \texttt{[], [-10], [-9], [-8], [-7], [-6], [-5], [-4], [-3], [-2], [-1], [0], [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [-947], [-450], [303], [886], [0 0], [0 1], [7 1], [-9 -1], [-11 40], [944 77]} & 32 & 0 \tabularnewline
 & RNG & vector of integers, all odd & 9 & 100 \tabularnewline
 & RNG & vector of integers, all even & 9 & 100 \tabularnewline
 & RNG & vector of integers, random probability of odd per vector & 150 & 1800 \tabularnewline
Mirror Image & HC & pair of vectors of integers: \texttt{([] []), ([1] [1]), ([0] [1]), ([1] [0]), ([-44] [16]), ([-13] [-12]), ([2 1] [1 2]), ([0 1] [1 1]), ([0 7] [7 0]), ([5 8] [5 8]), ([34 12] [34 12]), ([456 456] [456 456]), ([40 831] [-431 -680]), ([1 2 1] [1 2 1]), ([1 2 3 4 5 4 3 2 1] [1 2 3 4 5 4 3 2 1]), ([45 99 0 12 44 7 7 44 12 0 99 45] [45 99 0 12 44 7 7 44 12 0 99 45]), ([24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24] [24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24]), ([33 45 -941] [33 45 -941]), ([33 -941 45] [33 45 -941]), ([45 33 -941] [33 45 -941]), ([45 -941 33] [33 45 -941]), ([-941 33 45] [33 45 -941]), ([-941 45 33] [33 45 -941])}  & 23 & 0 \tabularnewline
 & RNG & pair of vectors of integers that are mirror image & 37 & 500 \tabularnewline
 & RNG & pair of equal vectors of integers & 10 & 100 \tabularnewline
 & RNG & pair of vectors of integers that are close to mirror image, but have a few elements changed & 20 & 200 \tabularnewline
 & RNG & pair of vectors of integers & 10 & 200 \tabularnewline
Super Anagrams & HC & pair of strings: \texttt{("" ""), ("h" ""), ("" "i"), ("a" "a"), ("c" "b"), ("nn" "n"), ("c" "abcde"), ("abcde" "c"), ("mnbvccxz" "r"), ("aabc" "abc"), ("abcde" "aabc"), ("edcba" "abcde"), ("moo" "mo"), ("mo" "moo"), ("though" "tree"), ("zipper" "rip"), ("rip" "flipper"), ("zipper" "hi"), ("dollars" "dealer"), ("louder" "loud"), ("ccccc" "ccccccccc"), ("oldwestaction" "clinteastwood"), ("ldwestaction" "clinteastwood"), ("verificationcomplete" "verificationcomplete"), ("hhhhhhhhhhaaaaaaaaaa" "hahahahahahahahahaha"), ("aahhhh" "hahahahahahahahahaha"), ("qwqeqrqtqyquqiqoqpqs" ""), ("qazwsxedcrfvtgbyhnuj" "wxyz"), ("gggffggfefeededdd" "dddeeefffgggg"), ("dddeeefffgggg" "gggffggfefeededdd")} & 30 & 0 \tabularnewline
 & RNG & pair of strings, chosen to be close to (or actually) super anagrams & 170 & 2000 \tabularnewline
Sum of Squares & HC & 1, 2, 3, 4, 5, 100 & 6 & 0 \tabularnewline
 & RNG & integer & 44 & 50 \tabularnewline
Vectors Summed & HC & pair of vectors of integers: \texttt{([] []), ([0] [0]), ([10] [0]), ([5] [3]), ([-9] [7]), ([0 0] [0 0]), ([-4 2] [0 1]), ([-3 0] [-1 0]), ([-323 49] [-90 -6])} & 10 & 0 \tabularnewline
 & RNG & pair of length 1 vectors of integers & 5 & 0 \tabularnewline
 & RNG & pair of length 50 vectors of integers & 10 & 100 \tabularnewline
 & RNG & pairs of vectors of integers & 125 & 1400 \tabularnewline
X-Word Lines & HC & pair of strings and integers (too long to print, see reference implementation for details) & 46 & 0 \tabularnewline
 & RNG & pair of strings and integers & 104 & 2000 \tabularnewline
\bottomrule
\end{tabular}
\end{table*}

\begin{table*}
\centering
\caption{Data domains for each benchmark problem (part 3).}
\label{datadomains3}
\rowcolors{3}{Gray}{white}
\begin{tabular}{>{\raggedright}p{3.5cm} l >{\raggedright}p{9.8cm} rr}
\toprule
\textbf{Name} & \textbf{Type} & \textbf{Domain} & \textbf{Train} & \textbf{Test} \\
\midrule
Pig Latin & HC & \texttt{"", "a", "b", "c", "d", "e", "i", "m", "o", "u", "y", "z", "hello", "there", "world", "eat", "apple", "yellow", "orange", "umbrella", "ouch", "in", "hello\textvisiblespace there\textvisiblespace world", "out\textvisiblespace at\textvisiblespace the\textvisiblespace plate", "nap\textvisiblespace time\textvisiblespace on\textvisiblespace planets", "supercalifragilistic", "expialidocious", "uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu", "ssssssssssssssssssssssssssssssssssssssssssssssssss", "w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w\textvisiblespace w", "e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e\textvisiblespace e", "ha\textvisiblespace ha\textvisiblespace ha\textvisiblespace ha\textvisiblespace ha\textvisiblespace ha\textvisiblespace ha\textvisiblespace ha\textvisiblespace ha\textvisiblespace ha\textvisiblespace ha\textvisiblespace ha\textvisiblespace ha\textvisiblespace ha\textvisiblespace ha\textvisiblespace ha\textvisiblespace ha", "x\textvisiblespace y\textvisiblespace x\textvisiblespace y\textvisiblespace x\textvisiblespace y\textvisiblespace x\textvisiblespace y\textvisiblespace x\textvisiblespace y\textvisiblespace x\textvisiblespace y\textvisiblespace x\textvisiblespace y\textvisiblespace x\textvisiblespace y\textvisiblespace x\textvisiblespace y\textvisiblespace x\textvisiblespace y\textvisiblespace x\textvisiblespace y\textvisiblespace x\textvisiblespace y\textvisiblespace x"} & 33 & 0 \tabularnewline
 & RNG & string & 167 & 1000 \tabularnewline
Negative To Zero & HC & vector of integers: \texttt{[], [-10], [-1], [0], [1], [10], [0 0], [0 1], [-1 0], [-90 -6], [-16 33], [412 111]} & 12 & 0 \tabularnewline
 & RNG & length 1 vector of integers & 5 & 0 \tabularnewline
 & RNG & vector of negative integers & 9 & 100 \tabularnewline
 & RNG & vector of positive integers & 9 & 100 \tabularnewline
 & RNG & vector of integers & 165 & 1800 \tabularnewline
Scrabble Score & HC & each single lowercase letter & 26 & 0 \tabularnewline
 & HC & each single uppercase letter & 0 & 26 \tabularnewline
 & HC & \texttt{"", "*", "\textvisiblespace ", "Q\textvisiblespace ", "zx", "\textvisiblespace Dw", "ef", "!!", "\textvisiblespace F@", "ydp", "4ps", "abcdefghijklmnopqrst", "ghijklmnopqrstuvwxyz", "zxyzxyqQQZXYqqjjawp", "h\textvisiblespace w\textvisiblespace h\textvisiblespace j\#\#r\#\#r\textbackslash\textvisiblespace n+JJL", "i\textvisiblespace !i\textvisiblespace !i\textvisiblespace !i\textvisiblespace !i", "QQQQQQQQQQQQQQQQQQQQ", "\$\$\$\$\$\$\$\$\$\$\$\$\$\$\$\$\$\$\$\$", "wwwwwwwwwwwwwwwwwwww", "1\textvisiblespace 1\textvisiblespace 1\textvisiblespace 1\textvisiblespace 1\textvisiblespace 1\textvisiblespace 1\textvisiblespace 1\textvisiblespace 1\textvisiblespace 1\textvisiblespace ", "\textvisiblespace v\textvisiblespace v\textvisiblespace v\textvisiblespace v\textvisiblespace v\textvisiblespace v\textvisiblespace v\textvisiblespace v\textvisiblespace v\textvisiblespace v", "Ha\textvisiblespace Ha\textvisiblespace Ha\textvisiblespace Ha\textvisiblespace Ha\textvisiblespace Ha\textvisiblespace Ha", "x\textvisiblespace y!x\textvisiblespace y!x\textvisiblespace y!x\textvisiblespace y!x\textvisiblespace y!", "G5G5G5G5G5G5G5G5G5G5"} & 24 & 0 \tabularnewline
 & RNG & string with at least 2 characters & 150 & 974 \tabularnewline
Word Stats & HC & string (too long to print, see reference implementation for details) & 36 & 0 \tabularnewline
 & RNG & string containing at least one sentence terminator & 64 & 1000 \tabularnewline
Checksum & HC & string (too long to print, see reference implementation for details) & 12 & 0 \tabularnewline
 & RNG & string & 88 & 1000 \tabularnewline
Digits & HC & -9495969798, -20008000, -777777, -9876, -482, -97, -20, 0, 19, 620, 24068, 512000, 8313227, 30000000, 9998887776 & 15 & 0 \tabularnewline
 & RNG & integer taken from logarithmic distribution & 85 & 1000 \tabularnewline
Grade & HC & quintuplet of integers: \texttt{(80 70 60 50 85), (80 70 60 50 80), (80 70 60 50 79), (80 70 60 50 75), (80 70 60 50 70), (80 70 60 50 69), (80 70 60 50 65), (80 70 60 50 60), (80 70 60 50 59), (80 70 60 50 55), (80 70 60 50 50), (80 70 60 50 49), (80 70 60 50 45), (90 80 70 60 100), (90 80 70 60 0), (4 3 2 1 5), (4 3 2 1 4), (4 3 2 1 3), (4 3 2 1 2), (4 3 2 1 1), (4 3 2 1 0), (100 99 98 97 100), (100 99 98 97 99), (100 99 98 97 98), (100 99 98 97 97), (100 99 98 97 96), (98 48 27 3 55), (98 48 27 3 14), (98 48 27 3 1), (45 30 27 0 1), (45 30 27 0 0), (48 46 44 42 40), (48 46 44 42 41), (48 46 44 42 42), (48 46 44 42 43), (48 46 44 42 44), (48 46 44 42 45), (48 46 44 42 46), (48 46 44 42 47), (48 46 44 42 48), (48 46 44 42 49)} & 41 & 0 \tabularnewline
 & RNG & quintuplet of integers, with the first four distinct and decreasing & 159 & 2000 \tabularnewline
Median & RNG & triplet of integers, all equal & 10 & 100 \tabularnewline
 & RNG & triplet of integers, two of three equal & 30 & 300 \tabularnewline
 & RNG & triplet of integers & 60 & 600 \tabularnewline
Smallest & HC & quadruplet of integers: \texttt{(0 0 0 0), (-44 -44 -7 -13), (0 4 -99 -33), (-22 -22 -22 -22), (99 100 99 100)} & 5 & 0 \tabularnewline
 & RNG & quadruplet of integers, all equal & 5 & 100 \tabularnewline
 & RNG & quadruplet of integers, three of four equal & 10 & 100 \tabularnewline
 & RNG & quadruplet of integers in range [0, 100] & 20 & 200 \tabularnewline
 & RNG & quadruplet of integers & 60 & 600 \tabularnewline
Syllables & HC & \texttt{"", "a", "v", "4", "o", "\textvisiblespace ", "aei", "ouy", "chf", "quite", "a\textvisiblespace r\textvisiblespace e9j>", "you\textvisiblespace are\textvisiblespace many\textvisiblespace yay\textvisiblespace yea", "ssssssssssssssssssss", "oooooooooooooooooooo", "wi\textvisiblespace wi\textvisiblespace wi\textvisiblespace wi\textvisiblespace wi\textvisiblespace wi\textvisiblespace wi", "x\textvisiblespace y\textvisiblespace x\textvisiblespace y\textvisiblespace x\textvisiblespace y\textvisiblespace x\textvisiblespace y\textvisiblespace x\textvisiblespace y\textvisiblespace ", "eioyeioyeioyeioyeioy"} & 17 & 0 \tabularnewline
 & RNG & string (with each char having 20\% chance of being a vowel) & 83 & 1000 \tabularnewline
\bottomrule
\end{tabular}
\end{table*}



%%% end info about our specific data domains




\subsection{Fitness Functions}

\begin{table*}[t]
\centering
\caption{The fitness functions used for each problem. For problems that require the program to print, we usually use Levenshtein distance on the printed string and the correct output. Additionally, many problems parse part or all of a printed string as a different data type and use another fitness function. For example, for the Number IO problem, if the printed output can be parsed as a float, it is done so and used as a float error. For such problems, an output that cannot be parsed correctly receives a penalty error.}
\label{tableFitnessFunctions}
\rowcolors{3}{Gray}{white}
\begin{tabular}{>{\raggedright}p{4cm} >{\raggedright}p{11cm}}
\toprule
\textbf{Problem}               & \textbf{Fitness Function}                                                                                                                        \tabularnewline
\midrule
Number IO                  & printed string Levenshtein distance; printed float error                                                                              \tabularnewline
Small Or Large             & printed string Levenshtein distance                                                                                                   \tabularnewline
For Loop Index             & printed string Levenshtein distance                                                                                                   \tabularnewline
Compare String Lengths     & boolean error                                                                                                                  \tabularnewline
Double Letters             & printed string Levenshtein distance                                                                                                   \tabularnewline
Collatz Numbers            & integer error                                                                                                                  \tabularnewline
Replace Space with Newline & printed string Levenshtein distance; integer error                                                                                    \tabularnewline
String Differences         & printed string Levenshtein distance; numeric difference in number of lines with correct format                                                \tabularnewline
Even Squares               & printed string Levenshtein distance; numeric difference in number of lines with correct format; printed integer error on each line                        \tabularnewline
Wallis Pi                  & float error; Levenshtein distance of string version of float                                                                          \tabularnewline
String Lengths Backwards   & printed string Levenshtein distance                                                                                                   \tabularnewline
Last Index of Zero         & integer error                                                                                                                  \tabularnewline
Vector Average             & float error                                                                                                                    \tabularnewline
Count Odds                 & integer error                                                                                                                  \tabularnewline
Mirror Image               & boolean error                                                                                                                  \tabularnewline
Super Anagrams             & boolean error                                                                                                                  \tabularnewline
Sum of Squares             & integer error                                                                                                                  \tabularnewline
Vectors Summed             & integer error at each position in vector \tabularnewline
X-Word Lines               & printed string Levenshtein distance; integer error for number of newlines; numeric difference in correct words on each line summed over lines \tabularnewline
Pig Latin                  & printed string Levenshtein distance                                                                                                   \tabularnewline
Negative To Zero           & integer vector Levenshtein distance                                                                                                   \tabularnewline
Scrabble Score             & integer error                                                                                                                  \tabularnewline
Word Stats                 & printed string Levenshtein distance; integer error for printed number of sentences; float error for printed average sentence length             \tabularnewline
Checksum                   & printed string Levenshtein distance; for last printed char in string, ASCII value error \tabularnewline
Digits                     & printed string Levenshtein distance                                                                                                   \tabularnewline
Grade                      & printed string Levenshtein distance; printed char error for grade char \tabularnewline
Median                     & printed string right/wrong \tabularnewline
Smallest                   & printed string right/wrong \tabularnewline
Syllables                  & printed string Levenshtein distance; printed integer error  \tabularnewline     
\bottomrule
\end{tabular}
\end{table*}

When using this benchmark suite with GP, we not only need the input/output cases, but also a method of measuring how well a particular program performs on each case---the \textit{fitness function}. 
%Fitness functions for these problems must not only match their respective output types, but must also give reasonable measurement of program performance. Still, we can present some generalities of our chosen fitness functions before pointing to the reference implementation for details.
Many of the problems in this suite print results to standard output, and we generally treat these outputs as strings and use Levenshtein distance (a measure of string edit distance) as the fitness function. Other problems produce numeric outputs, either returned or printed; for these problems we use absolute error for fitness, parsing printed numbers when necessary and possible. Some problems produce boolean values, or are best measured by a simple binary right or wrong; here, we use a fitness of 0 for right and 1 for wrong. Finally, some problems require problem-tailored fitness functions, such as vector edit distance or string formatting requirements. We give the details of each fitness function in Table \ref{tableFitnessFunctions}.

For some problems we found it appropriate to use multiple fitness functions per test case. For example, the Replace Space With Newline problem requires both a printed string and a returned integer. For problems like this, we produce multiple fitness values for a single case. Additionally, we find that PushGP performs better on some problems when we use more than one fitness value per case, even where not strictly necessary. For example, we found no solutions to the X-Word Lines problem when using Levenshtein distance as the only fitness function, but found solutions when adding additional fitness functions for the number of newline characters and summed errors of differences in number of words compared. When using multiple fitness values for a single training case, we treat each fitness value separately when the parent selection method requires it; in tournament selection, we simply sum all fitness values.

% Standard: 11111 11111 11111 1111 (string Levenshtein; integer error; boolean error; float error; integer error at each index of integer vector)
% Non-standard: 11111 11111
Since these problems aim to test how well a system would perform on real program synthesis applications, we try to keep fitness functions simple to resemble those that might be used by practitioners. For the majority of the problems in this suite (19 out of 29), we use a basic fitness function based on the type of the output. The basic fitness function for integers and floats is absolute numeric distance; for booleans it is right/wrong; for printed strings it is either right/wrong or Levenshtein distance. Most of the problems for which we use problem-specific fitness functions require a printed string as output, and attempt to parse that string to provide extra information based on the problem's expected output. We try to not put too much knowledge about a problem into the problem-specific fitness functions, but instead choose functions that are fairly obvious based on the problem descriptions.


\begin{table*}%[t]
\centering
\caption{Instructions and data types used in our PushGP implementation of each problem. The column ``\# Instructions'' reports the number of instructions, terminals, and ERCs used for each problem. The middle columns show which data types were used for each problem. For example, the Number IO problem used all instructions relevant to integers, floats, and printing. The last column lists the constants and ERCs used for the problem; ERC ranges are given in Table \ref{tableERCranges}. Here, char constants are represented in the Clojure style, starting with a backslash, and strings are surrounded by double quotation marks. The ``Problems'' row simply counts how many problems use each data type. The ``Instructions'' row shows the number of Push instructions that primarily use each data type; some use multiple types but are only counted once.}
\label{tableDataTypes}
\rowcolors{3}{Gray}{white}
\begin{tabular}{>{\raggedright}p{2.6cm}rccccccccccc>{\raggedright}p{5.5cm}}
%\begin{tabular}{>{\raggedright}p{3.1cm}rccccccccccc>{\raggedright}p{5.5cm}}
%\hline
\toprule
\textbf{Problem} & \begin{sideways}\textbf{\# Instructions} \end{sideways} & \begin{sideways}\textbf{exec}\end{sideways} & \begin{sideways}\textbf{integer}\end{sideways} & \begin{sideways}\textbf{float}\end{sideways} & \begin{sideways}\textbf{boolean}\end{sideways} & \begin{sideways}\textbf{char}\end{sideways} &  \begin{sideways}\textbf{string}\end{sideways} & \begin{sideways}\textbf{vector of integers} \end{sideways} & \begin{sideways}\textbf{vector of floats}\end{sideways} & \begin{sideways}\textbf{vector of strings}\end{sideways} & \begin{sideways}\textbf{print}\end{sideways} & \begin{sideways}\textbf{file input}\end{sideways} & \textbf{Terminals (besides inputs)} \tabularnewline
%\hline
%\hline
\midrule
Number IO                  & 50              &      & x       & x     &         &      &        &                    &                  &                   & x     &            & integer ERC, float ERC                                                                                                                                                                                                      \tabularnewline
%\hline
Small Or Large             & 103             & x    & x       &       & x       &      & x      &                    &                  &                   & x     &            & ``small'', ``large'', integer ERC                                                                                                                                                                                               \tabularnewline
%\hline
For Loop Index             & 74              & x    & x       &       & x       &      &        &                    &                  &                   & x     &            &                                                                                                                                                                                                                             \tabularnewline
%\hline
Compare String Lengths     & 98              & x    & x       &       & x       &      & x      &                    &                  &                   &       &            & boolean ERC                                                                                                                                                                                                                 \tabularnewline
%\hline
Double Letters             & 132             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & \textbackslash !                                                                                                                                                                                                            \tabularnewline
%\hline
Collatz Numbers            & 102             & x    & x       & x     & x       &      &        &                    &                  &                   &       &            & 0, 1, integer ERC                                                                                                                                                                                                           \tabularnewline
%\hline
Replace Space with Newline & 135             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & \textbackslash space, \textbackslash newline, string ERC, char ERC                                                                                                                                                          \tabularnewline
%\hline
String Differences         & 135             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & \textbackslash space, \textbackslash newline, integer ERC                                                                                                                                                                   \tabularnewline
%\hline
Even Squares               & 72              & x    & x       &       & x       &      &        &                    &                  &                   & x     &            &                                                                                                                                                                                                                             \tabularnewline
%\hline
Wallis Pi                  & 103             & x    & x       & x     & x       &      &        &                    &                  &                   &       &            & 2 integer ERCs, 2 float ERCs                                                                                                                                                                                                \tabularnewline
%\hline
String Lengths Backwards   & 134             & x    & x       &       & x       &      & x      &                    &                  & x                 & x     &            & integer ERC                                                                                                                                                                                                                 \tabularnewline
%\hline
Last Index of Zero         & 101             & x    & x       &       & x       &      &        & x                  &                  &                   &       &            & 0                                                                                                                                                                                                                           \tabularnewline
%\hline
Vector Average             & 88              & x    & x       & x     &         &      &        &                    & x                &                   &       &            &                                                                                                                                                                                                                             \tabularnewline
%\hline
Count Odds                 & 104             & x    & x       &       & x       &      &        & x                  &                  &                   &       &            & 0, 1, 2, integer ERC                                                                                                                                                                                                        \tabularnewline
%\hline
Mirror Image               & 102             & x    & x       &       & x       &      &        & x                  &                  &                   &       &            & boolean ERC                                                                                                                                                                                                                 \tabularnewline
%\hline
Super Anagrams             & 129             & x    & x       &       & x       & x    & x      &                    &                  &                   &       &            & boolean ERC, char ERC, integer ERC                                                                                                                                                                                          \tabularnewline
%\hline
Sum of Squares             & 71              & x    & x       &       & x       &      &        &                    &                  &                   &       &            & 0, 1, integer ERC                                                                                                                                                                                                           \tabularnewline
%\hline
Vectors Summed             & 68              & x    & x       &       &         &      &        & x                  &                  &                   &       &            & {[}{]}, integer ERC                                                                                                                                                                                                         \tabularnewline
%\hline
X-Word Lines               & 134             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & \textbackslash newline, \textbackslash space                                                                                                                                                                                \tabularnewline
%\hline
Pig Latin                  & 141             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & ``ay'', \textbackslash space, \textbackslash a, \textbackslash e, \textbackslash i, \textbackslash o, \textbackslash u, ``aeiou'', string ERC, char ERC                                                                         \tabularnewline
%\hline
Negative To Zero           & 102             & x    & x       &       & x       &      &        & x                  &                  &                   &       &            & 0, {[}{]}                                                                                                                                                                                                                   \tabularnewline
%\hline
Scrabble Score             & 158             & x    & x       &       & x       & x    & x      & x                  &                  &                   &       &            & vector containing Scrabble values (indexed by ASCII values)                                                                                                                                                                 \tabularnewline
%\hline
Word Stats                 & 281             & x    & x       & x     & x       & x    & x      & x                  & x                & x                 & x     & x          & \textbackslash ., \textbackslash ?, \textbackslash !, \textbackslash space, \textbackslash tab, \textbackslash newline, {[}{]}, ``words of length~'', ``:~'', ``number of sentences:~'', ``average sentence length:~'', integer ERC \tabularnewline
%\hline
Checksum                   & 136             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & ``Check sum is~'', \textbackslash space, 64, integer ERC, char ERC                                                                                                                                                            \tabularnewline
%\hline
Digits                     & 133             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & \textbackslash newline, integer ERC {[}-10, 10{]}                                                                                                                                                                           \tabularnewline
%\hline
Grade                      & 112             & x    & x       &       & x       &      & x      &                    &                  &                   & x     &            & ``Student has a~'', ``~grade.'', ``A'', ``B'', ``C'', ``D'', ``F'', integer ERC                                                                                                                                                           \tabularnewline
%\hline
Median                     & 75              & x    & x       &       & x       &      &        &                    &                  &                   & x     &            & integer ERC                                                                                                                                                                                                                 \tabularnewline
%\hline
Smallest                   & 76              & x    & x       &       & x       &      &        &                    &                  &                   & x     &            & integer ERC                                                                                                                                                                                                                 \tabularnewline
%\hline
Syllables                  & 141             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & ``The number of syllables is~'', ``aeiouy'', \textbackslash a, \textbackslash e, \textbackslash i, \textbackslash o, \textbackslash u, \textbackslash y, char ERC, string ERC                                                   \tabularnewline
%\hline
%\hline
\midrule
\rowcolor{white} Problems                      &                 & 28   & 29      & 5     & 26      & 11   & 15     & 7                  & 2                & 2                 & 17    & 1          &                                                                                                                                                                                                                             \tabularnewline
%\hline
\rowcolor{white} Instructions     &                 & 28   & 28      & 31    & 19      & 17   & 39     & 31                 & 31               & 31                & 10    & 4          &                                                                                                                                                                                                                             \tabularnewline
\bottomrule
%\hline
\end{tabular}
\end{table*}

\subsection{Instruction Sets}

As discussed in Section \ref{synthProbSpec}, we have chosen to specify the data types relevant to each problem, and then include all instructions that use those data types in each problem's instruction set. Table \ref{tableDataTypes} presents the Push data types we chose for each problem. The ``exec'' column signifies instructions that use Push's exec stack, which typically perform control flow manipulations such as conditionals, iteration, and subfunctions defined through tagging \cite{Spector:2011:GECCO}. The ``print'' column includes instructions that print data to standard output, and ``file input'' includes a small set of file reading instructions. 

Table \ref{tableDataTypes} also gives the terminals used for each problem, which encompass constants and ephemeral random constants (ERCs). ERCs allow for the creation of random constants in randomly generated code during initialization and mutation. We used problem-specific ERC ranges, which can be found in Table \ref{tableERCranges}. These ranges were selected as seemed appropriate for each problem; we do not anticipate varying from these ranges will have significant impact on results.

\begin{table*}[t]
\centering
\caption{ERC ranges used in our problems. For char and string ERCs, ``visible chars'' indicates all visible ASCII characters plus space, newline, and tab.}
\label{tableERCranges}
\rowcolors{3}{Gray}{white}
\begin{tabular}{l>{\raggedright}p{10.6cm}}
\toprule
Problem                    & ERC Ranges \tabularnewline
\midrule
Number IO                  & integer ERC $[-100, 100]$, float ERC $[-100.0, 100.0)$ \tabularnewline
Small Or Large             & integer ERC $[-10000,10000]$        \tabularnewline
For Loop Index             &                         \tabularnewline
Compare String Lengths     & boolean ERC $[true, false]$ \tabularnewline
Double Letters             & \tabularnewline
Collatz Numbers            & integer ERC $[-100, 100]$  \tabularnewline
Replace Space with Newline & char ERC (visible chars), string ERC (lowercase letters and spaces, with space having 20\% chance at each character)   \tabularnewline
String Differences         & integer ERC $[-10, 10]$                       \tabularnewline
Even Squares               & \tabularnewline
Wallis Pi                  & integer ERC $[-10, 10]$, integer ERC $[-500, 500]$, float ERC $[-500.0, 500.0)$ \tabularnewline
String Lengths Backwards   & integer ERC $[-100, 100]$               \tabularnewline
Last Index of Zero         & integer ERC $[-50, 50]$     \tabularnewline
Vector Average             &     \tabularnewline
Count Odds                 & integer ERC $[-1000, 1000]$       \tabularnewline
Mirror Image               & boolean ERC $[true, false]$          \tabularnewline
Super Anagrams             & boolean ERC $[true, false]$, integer ERC $[-1000, 1000]$, char ERC (visible chars) \tabularnewline
Sum of Squares             & integer ERC $[-100, 100]$       \tabularnewline
Vectors Summed             & integer ERC $[-1000, 1000]$            \tabularnewline
X-Word Lines               &             \tabularnewline
Pig Latin                  & char ERC (visible chars), string ERC (lowercase letters and spaces, with space having 20\% chance at each character)  \tabularnewline
Negative To Zero           &             \tabularnewline
Scrabble Score             & \tabularnewline
Word Stats                 & integer ERC $[-100, 100]$           \tabularnewline
Checksum                   & integer ERC $[-128, 128]$, char ERC (visible chars)      \tabularnewline
Digits                     & integer ERC $[-10, 10]$          \tabularnewline
Grade                      & integer ERC $[0, 100]$         \tabularnewline
Median                     & integer ERC $[-100, 100]$            \tabularnewline
Smallest                   & integer ERC $[-100, 100]$           \tabularnewline
Syllables                  & char ERC (visible chars), string ERC (lowercase letters, spaces, digits, and symbols, with vowels having 20\% chance at each character) \tabularnewline
\bottomrule
\end{tabular}
\end{table*}



% NOTE: Instructions added after the fact, which will have to be re-added if have to get the instructions from Clojush again:
% tag
% tagged
% file_readline
% file_readchar
% file_EOF
% file_begin
%    [Also: moved print instructions to be all together]
\begin{table*}
\centering
\caption{Push data types and instructions used in our experiments. For each combination of data types listed in the first column, we list all of the Push instructions that are included in the instruction set when those data types are present for the problem. Continued in Table \ref{typesAndInstructionsTable2}.}
\label{typesAndInstructionsTable}
\rowcolors{3}{Gray}{white}
\begin{tabular}{>{\raggedright}p{4cm} >{\raggedright}p{13cm}}
\toprule
\textbf{Data Types} & \textbf{Instructions} \tabularnewline
\midrule
boolean & boolean\_empty, boolean\_swap, boolean\_eq, boolean\_invert\_first\_then\_and, boolean\_flush, boolean\_rot, boolean\_and, boolean\_invert\_second\_then\_and, boolean\_xor, boolean\_not, boolean\_or, boolean\_dup, boolean\_pop \tabularnewline
boolean, char & char\_iswhitespace, char\_empty, char\_isletter, char\_eq, char\_isdigit \tabularnewline
boolean, char, string & string\_containschar \tabularnewline
boolean, exec & exec\_eq, exec\_when, exec\_if, exec\_do*while, exec\_while, exec\_empty \tabularnewline
boolean, float & float\_lt, boolean\_fromfloat, float\_empty, float\_lte, float\_gte, float\_fromboolean, float\_gt, float\_eq \tabularnewline
boolean, float, vector\_float & vector\_float\_contains \tabularnewline
boolean, integer & integer\_eq, boolean\_yank, integer\_gte, integer\_lt, integer\_lte, boolean\_shove, integer\_empty, integer\_gt, integer\_fromboolean, boolean\_frominteger, boolean\_stackdepth, boolean\_yankdup \tabularnewline
boolean, integer, vector\_integer & vector\_integer\_contains \tabularnewline
boolean, string & string\_eq, string\_emptystring, string\_fromboolean, string\_contains, string\_empty \tabularnewline
boolean, string, vector\_string & vector\_string\_contains \tabularnewline
boolean, vector\_float & vector\_float\_emptyvector, vector\_float\_empty, vector\_float\_eq \tabularnewline
boolean, vector\_integer & vector\_integer\_eq, vector\_integer\_empty, vector\_integer\_emptyvector \tabularnewline
boolean, vector\_string & vector\_string\_empty, vector\_string\_emptyvector, vector\_string\_eq \tabularnewline
char & char\_dup, char\_swap, char\_flush, char\_rot, char\_pop \tabularnewline
char, exec, string & exec\_string\_iterate \tabularnewline
char, float & char\_fromfloat, float\_fromchar \tabularnewline
char, integer & char\_shove, char\_stackdepth, integer\_fromchar, char\_yank, char\_yankdup, char\_frominteger \tabularnewline
char, integer, string & string\_occurrencesofchar, string\_setchar, string\_nth, string\_indexofchar \tabularnewline
char, string & string\_removechar, char\_allfromstring, string\_replacefirstchar, string\_replacechar, string\_conjchar, string\_fromchar, string\_first, string\_last \tabularnewline
exec & exec\_y, exec\_pop, exec\_rot, exec\_s, exec\_k, exec\_flush, exec\_swap, exec\_dup, exec\_noop, tag, tagged \tabularnewline
exec, float, vector\_float & exec\_do*vector\_float \tabularnewline
exec, integer & exec\_stackdepth, exec\_do*times, exec\_do*count, exec\_do*range, exec\_yank, exec\_yankdup, exec\_shove \tabularnewline
exec, integer, vector\_integer & exec\_do*vector\_integer \tabularnewline
exec, string, vector\_string & exec\_do*vector\_string \tabularnewline
file & file\_readline, file\_readchar, file\_EOF, file\_begin \tabularnewline
float & float\_rot, float\_sin, float\_cos, float\_swap, float\_div, float\_inc, float\_sub, float\_flush, float\_add, float\_tan, float\_mult, float\_max, float\_pop, float\_min, float\_dup, float\_dec, float\_mod \tabularnewline
float, integer & float\_yank, float\_frominteger, float\_stackdepth, float\_shove, float\_yankdup, integer\_fromfloat \tabularnewline
float, integer, vector\_float & vector\_float\_indexof, vector\_float\_occurrencesof, vector\_float\_nth, vector\_float\_set \tabularnewline
float, string & float\_fromstring, string\_fromfloat \tabularnewline
float, vector\_float & vector\_float\_conj, vector\_float\_remove, vector\_float\_last, vector\_float\_first, vector\_float\_replacefirst, vector\_float\_pushall, vector\_float\_replace \tabularnewline
integer & integer\_add, integer\_swap, integer\_yank, integer\_dup, integer\_yankdup, integer\_flush, integer\_shove, integer\_mult, integer\_stackdepth, integer\_div, integer\_inc, integer\_max, integer\_sub, integer\_mod, integer\_rot, integer\_dec, integer\_min, integer\_pop \tabularnewline
integer, string & string\_substring, string\_take, string\_frominteger, string\_stackdepth, integer\_fromstring, string\_yank, string\_yankdup, string\_length, string\_shove \tabularnewline
integer, string, vector\_string & vector\_string\_indexof, vector\_string\_set, vector\_string\_nth, vector\_string\_occurrencesof \tabularnewline
integer, vector\_float & vector\_float\_shove, vector\_float\_length, vector\_float\_stackdepth, vector\_float\_subvec, vector\_float\_yank, vector\_float\_take, vector\_float\_yankdup \tabularnewline
integer, vector\_integer & vector\_integer\_remove, vector\_integer\_pushall, vector\_integer\_yank, vector\_integer\_subvec, vector\_integer\_last, vector\_integer\_first, vector\_integer\_shove, vector\_integer\_indexof, vector\_integer\_occurrencesof, vector\_integer\_replace, vector\_integer\_replacefirst, vector\_integer\_take, vector\_integer\_stackdepth, vector\_integer\_nth, vector\_integer\_set, vector\_integer\_length, vector\_integer\_yankdup, vector\_integer\_conj \tabularnewline
integer, vector\_string & vector\_string\_stackdepth, vector\_string\_subvec, vector\_string\_take, vector\_string\_shove, vector\_string\_yank, vector\_string\_length, vector\_string\_yankdup \tabularnewline
\bottomrule
\end{tabular}
\end{table*}

\begin{table*}[t]
\centering
\caption{Continuation of Table \ref{typesAndInstructionsTable}.}
\label{typesAndInstructionsTable2}
\rowcolors{3}{Gray}{white}
\begin{tabular}{>{\raggedright}p{3cm} >{\raggedright}p{14cm}}
\toprule
\textbf{Data Types} & \textbf{Instructions} \tabularnewline
\midrule
print & print\_newline \tabularnewline
print, boolean & print\_boolean \tabularnewline
print, char & print\_char \tabularnewline
print, exec & print\_exec \tabularnewline
print, float & print\_float \tabularnewline
print, integer & print\_integer \tabularnewline
print, string & print\_string \tabularnewline
print, vector\_float & print\_vector\_float \tabularnewline
print, vector\_integer & print\_vector\_integer \tabularnewline
print, vector\_string & print\_vector\_string \tabularnewline
string & string\_pop, string\_rot, string\_rest, string\_parse\_to\_chars, string\_reverse, string\_swap, string\_split, string\_flush, string\_replacefirst, string\_butlast, string\_concat, string\_replace, string\_dup \tabularnewline
string, vector\_string & vector\_string\_remove, vector\_string\_conj, vector\_string\_first, vector\_string\_pushall, vector\_string\_last, vector\_string\_replacefirst, vector\_string\_replace \tabularnewline
vector\_float & vector\_float\_dup, vector\_float\_pop, vector\_float\_rot, vector\_float\_swap, vector\_float\_flush, vector\_float\_reverse, vector\_float\_rest, vector\_float\_concat, vector\_float\_butlast \tabularnewline
vector\_integer & vector\_integer\_swap, vector\_integer\_butlast, vector\_integer\_flush, vector\_integer\_rest, vector\_integer\_concat, vector\_integer\_rot, vector\_integer\_reverse, vector\_integer\_pop, vector\_integer\_dup \tabularnewline
vector\_string & vector\_string\_dup, vector\_string\_rot, vector\_string\_rest, vector\_string\_reverse, vector\_string\_butlast, vector\_string\_concat, vector\_string\_pop, vector\_string\_flush, vector\_string\_swap \tabularnewline
\bottomrule
\end{tabular}
\end{table*}

Tables \ref{typesAndInstructionsTable} and \ref{typesAndInstructionsTable2} show every Push instruction used in our experiments, and the data types that they require. For example, the string\_containschar instruction requires that the boolean, char, and string data types be used for a problem in order to be included; this is because it must use a string and a char as inputs, and returns a boolean of whether the input string contains the input char. These tables are intended to give an idea of the scope and complexity of the instructions used in our experiments. Attempting the problems here in another system would obviously require a different set of instructions specific to the programming language of the search. While we would expect such a system to use different instructions, we would also expect similar numbers of instructions that are not cherry-picked for the individual problems.


\subsection{GP Parameters}


In the most recent version of PushGP, genomes are represented by flat sequences of instructions that may have one or more epigenetic markers attached to each instruction. In this work, we use the default epigenetic markers, which only include a marker that tells how many pairs of parentheses to close after each instruction when translating the genome into a Push program. We initialize genomes by selecting a genome size uniformly between 0 and the maximum initial genome size, which for these runs we set to half of the maximum genome size. Each gene is composed of an instruction taken uniformly from the available instructions and literals, as well as an epigenetic marker for parentheses ranging from 0 to 3, weighted toward 0.

\begin{table}%[t]
\centering
\caption{The PushGP parameters that were held constant across the problems. Alternation is a uniform crossover operator similar to ULTRA \cite{spector:2014:GPTP}. Uniform mutation has a constant probability of replacing each instruction. Uniform close mutation increases or decreases the number of closing parentheses after each instruction probabilistically. Alignment deviation is the standard deviation of index changes during alternation, and for four problems was set to 5 (Number IO, Small Or Large, Median, and Smallest).}
\label{tableGPconstantParams}
%\rowcolors{3}{Gray}{white}
\begin{tabular}{l r}
\toprule
Parameter & Value \tabularnewline
\midrule
population size & 1000 \tabularnewline
alternation rate & 0.01 \tabularnewline
alignment deviation & 10 \tabularnewline
uniform mutation rate & 0.01 \tabularnewline
uniform close mutation rate & 0.1 \tabularnewline
\midrule
Genetic Operator & Prob \tabularnewline
\midrule
alternation & 0.2 \tabularnewline
uniform mutation & 0.2 \tabularnewline
uniform close mutation & 0.1 \tabularnewline
alternation followed by uniform mutation & 0.5 \tabularnewline
\bottomrule
\end{tabular}
\end{table}

%\begin{table}
%\centering
%\caption{SOMETHING}
%\label{tableGeneticOperators}
%\rowcolors{3}{Gray}{white}
%\begin{tabular}{lr}
%\toprule
%Genetic Operator & Probability \tabularnewline
%\midrule
%alternation & 0.2 \tabularnewline
%uniform mutation & 0.2 \tabularnewline
%uniform close mutation & 0.1 \tabularnewline
%alternation followed by uniform mutation & 0.5 \tabularnewline
%\bottomrule
%\end{tabular}
%\end{table}





\begin{table}%[t]
\centering
\caption{The PushGP parameters that we varied per problem. ``Max Prog Size'' gives the maximum number of instructions that can appear in an individual's genome. ``Eval Limit'' is the number of steps of the Push interpreter that are executed before stopping a program's execution; programs halted in this way will may still achieve good results if they print or return results before they are stopped. ``Max Gens'' gives the maximum number of generations in a single PushGP run. ``Program Evaluation Budget'' is the maximum number of programs that will be evaluated before a run is terminated.}
\label{tableGPParameters}
\rowcolors{3}{Gray}{white}
\begin{tabular}{>{\raggedright}m{2.5cm} >{\raggedleft}p{0.6cm} >{\raggedleft}p{0.8cm} >{\raggedleft}p{0.6cm}   >{\raggedleft}p{1.6cm}}
\toprule
Problem                    & Max Prog Size & Eval Limit & Max Gens & Program Evaluation Budget \tabularnewline
\midrule
Number IO                  & 200           & 200            & 200      & 5,000,000                 \tabularnewline
Small Or Large             & 200           & 300            & 300      & 30,000,000                \tabularnewline
For Loop Index             & 300           & 600            & 300      & 30,000,000                \tabularnewline
Compare String Lengths     & 400           & 600            & 300      & 30,000,000                \tabularnewline
Double Letters             & 800           & 1600           & 300      & 30,000,000                \tabularnewline
Collatz Numbers            & 600           & 15000          & 300      & 60,000,000                \tabularnewline
Replace Space with Newline & 800           & 1600           & 300      & 30,000,000                \tabularnewline
String Differences         & 1000          & 2000           & 300      & 60,000,000                \tabularnewline
Even Squares               & 400           & 2000           & 300      & 30,000,000                \tabularnewline
Wallis Pi                  & 600           & 8000           & 300      & 45,000,000                \tabularnewline
String Lengths Backwards   & 300           & 600            & 300      & 30,000,000                \tabularnewline
Last Index of Zero         & 300           & 600            & 300      & 45,000,000                \tabularnewline
Vector Average             & 400           & 800            & 300      & 30,000,000                \tabularnewline
Count Odds                 & 500           & 1500           & 300      & 60,000,000                \tabularnewline
Mirror Image               & 300           & 600            & 300      & 30,000,000                \tabularnewline
Super Anagrams             & 800           & 1600           & 300      & 60,000,000                \tabularnewline
Sum of Squares             & 400           & 4000           & 300      & 15,000,000                \tabularnewline
Vectors Summed             & 500           & 1500           & 300      & 45,000,000                \tabularnewline
X-Word Lines               & 800           & 1600           & 300      & 45,000,000                \tabularnewline
Pig Latin                  & 1000          & 2000           & 300      & 60,000,000                \tabularnewline
Negative To Zero           & 500           & 1500           & 300      & 60,000,000                \tabularnewline
Scrabble Score             & 1000          & 2000           & 300      & 60,000,000                \tabularnewline
Word Stats                 & 1000          & 6000           & 300      & 30,000,000                \tabularnewline
Checksum                   & 800           & 1500           & 300      & 30,000,000                \tabularnewline
Digits                     & 300           & 600            & 300      & 30,000,000                \tabularnewline
Grade                      & 400           & 800            & 300      & 60,000,000                \tabularnewline
Median                     & 200           & 200            & 200      & 20,000,000                \tabularnewline
Smallest                   & 200           & 200            & 200      & 20,000,000                \tabularnewline
Syllables                  & 800           & 1600           & 300      & 30,000,000                \tabularnewline
\bottomrule
\end{tabular}
\end{table}


In our experiment, we keep most of our PushGP system parameters constant across all problems, with specific details in Table \ref{tableGPconstantParams}. The genetic operators in our system work on the linear Push genomes as described in Table \ref{tableGPconstantParams}.
The only significant PushGP parameters that we vary per problem are the maximum program size, the maximum number of instruction evaluations that a program may use per execution, and the maximum number of generations per run. We varied these parameters based on expected problem difficulty and expected program size necessary to solve each problem; the exact values are given in Table \ref{tableGPParameters}. By specifying the maximum generations, the population size (1000 for all of our runs), and the size of the training set (see Table \ref{testCasesTable}), we also specify the program evaluation budget, which is the product of those values.


\section{Experimental Results}

%[TMH: I FEEL LIKE SOMETHING LIKE THE FOLLOWING NEEDS TO BE IN HERE, UNLESS IT'S DISCUSSED LATER IN THIS SECTION]
Whereas the relevance of a benchmark suite is determined by how well its problems reflect potential applications of the test systems, its utility is based on how well it differentiates between different approaches. We aim to include problems with a large range of difficulties, from those that can be solved reliably to those that extend beyond the abilities of current program synthesis systems. More importantly, we hope to include problems that are solved more often with some systems or settings than others, allowing us to compare their performances on these problems.
In this section we present a simple experiment showing the utility of the benchmark suite presented here. This experiment compares three parent selection algorithms: tournament selection, implicit fitness sharing, and lexicase selection.

Implicit fitness sharing (IFS) is a modification of tournament selection designed to encourage diversity preservation in the population \cite{McKay:2000:GECCO}. IFS selection greatly rewards individuals for solving training cases that are solved by a small fraction of the population, and gives less reward for solving cases that are solved by more of the population. Most of the problems here produce non-binary error values, for which we use the non-binary adaptation of IFS found in \cite{Krawiec:2013:EvoIASP}. As required by this method, we normalize error values to $[0, 1]$ by dividing each error by a maximum allowed error value, which differs per problem based on the fitness function.

Lexicase selection \cite{Helmuth:2014:ieeeTEC}, %, Spector:2012:APM:2330784.2330846}, %maybe remove the second citation here if need space?
 unlike tournament selection and IFS, does not base selection on a single fitness value. Instead, it uses a random ordering of the training set to select individuals that perform as well as possible on a subset of the cases even if they exhibit poor performance on other cases. Lexicase selection has been shown to improve the performance of a GP system on a variety of problems \cite{Helmuth:2014:ieeeTEC, Helmuth:2014:GECCO}.
%, Helmuth:2013:GECCOcomp}. %Maybe take out the last reference here if need room

%\begin{table}[t]
%\centering
%\caption{Number of successful runs out of 100 for each setting, where ``Tourn'' is size 7 tournament selection, ``IFS'' is implicit fitness sharing with size 7 tournaments, and ``Lex'' is lexicase selection. For each problem, \underline{underline} indicates significant improvement over the other two selection methods at $p < 0.05$ based on a pairwise chi-square test with Holm correction \cite{R}, or a pairwise Fisher's exact test with Holm correction if any number of successes is below 5 \cite{fmsb}. The ``Size'' column indicates the smallest size of any simplified solution program.}
%\label{tableResults}
%\rowcolors{3}{Gray}{white}
%\begin{tabular}{lrrr|r}
%\toprule
%Problem                    & Tourn & IFS & Lex & Size \\
%\midrule
%Number IO                  & 68      & 72  & \underline{98}       & 5    \\
%Small Or Large             & 3       & 3   & 5        & 27   \\
%For Loop Index             & 0       & 0   & 1        & 21   \\
%Compare String Lengths     & 3       & 6   & 7        & 11   \\
%Double Letters             & 0       & 0   & 6        & 20   \\
%Collatz Numbers            & 0       & 0   & 0        &     \\
%Replace Space with Newline & 8       & 16  & \underline{51}       & 9    \\
%String Differences         & 0       & 0   & 0        &     \\
%Even Squares               & 0       & 0   & 2        & 37   \\
%Wallis Pi                  & 0       & 0   & 0        &     \\
%String Lengths Backwards   & 7       & 10  & \underline{66}       & 9    \\
%Last Index of Zero         & 8       & 4   & \underline{21}       & 5    \\
%Vector Average             & 14      & 13  & 16       & 7    \\
%Count Odds                 & 0       & 0   & \underline{8}        & 7    \\
%Mirror Image               & 46      & 64  & \underline{78}       & 4    \\
%Super Anagrams             & 0       & 0   & 0        &     \\
%Sum of Squares             & 2       & 0   & 6        & 7    \\
%Vectors Summed             & 0       & 0   & 1        & 11   \\
%X-Word Lines               & 0       & 0   & \underline{8}        & 15   \\
%Pig Latin                  & 0       & 0   & 0        &     \\
%Negative To Zero           & 10      & 8   & \underline{45}       & 8    \\
%Scrabble Score             & 0       & 0   & 2        & 14   \\
%Word Stats                 & 0       & 0   & 0        &     \\
%Checksum                   & 0       & 0   & 0        &     \\
%Digits                     & 0       & 1   & 7        & 20   \\
%Grade                      & 0       & 0   & 4        & 52   \\
%Median                     & 7       & 43  & 45       & 10   \\
%Smallest                   & 75      & \underline{98}  & 81       & 8    \\
%Syllables                  & 1       & 7   & 18       & 14   \\
%%Number IO                  & 68      & 72  & \underline{98}       \\
%%Small Or Large             & 3       & 3   & 5        \\
%%For Loop Index             & 0       & 0   & 1        \\
%%Compare String Lengths     & 3       & 6   & 7        \\
%%Double Letters             & 0       & 0   & 6        \\
%%Collatz Numbers            & 0       & 0   & 0        \\
%%Replace Space with Newline & 8       & 16  & \underline{51}       \\
%%String Differences         & 0       & 0   & 0        \\
%%Even Squares               & 0       & 0   & 2        \\
%%Wallis Pi                  & 0       & 0   & 0        \\
%%String Lengths Backwards   & 7       & 10  & \underline{66}       \\
%%Last Index of Zero         & 8       & 4   & \underline{21}       \\
%%Vector Average             & 14      & 13  & 16       \\
%%Count Odds                 & 0       & 0   & 8        \\
%%Mirror Image               & 46      & 64  & \underline{78}       \\
%%Super Anagrams             & 0       & 0   & 0        \\
%%Sum of Squares             & 2       & 0   & 6        \\
%%Vectors Summed             & 0       & 0   & 1        \\
%%X-Word Lines               & 0       & 0   & \underline{8}        \\
%%Pig Latin                  & 0       & 0   & 0        \\
%%Negative To Zero           & 10      & 8   & \underline{45}       \\
%%Scrabble Score             & 0       & 0   & 2        \\
%%Word Stats                 & 0       & 0   & 0        \\
%%Checksum                   & 0       & 0   & 0        \\
%%Digits                     & 0       & 1   & 7        \\
%%Grade                      & 0       & 0   & 4        \\
%%Median                     & 7       & 43  & 45       \\
%%Smallest                   & 75      & \underline{98}  & 81       \\
%%Syllables                  & 1       & 7   & 18       \\
%\midrule
%\rowcolor{white} Problems Solved          & 13       & 13      & 22 &   \\
%\bottomrule
%\end{tabular}
%\end{table}

\begin{table*}[t]
\centering
\caption{The first three columns give the number of successful runs out of 100 for each setting, where ``Tourn'' is size 7 tournament selection, ``IFS'' is implicit fitness sharing with size 7 tournaments, and ``Lex'' is lexicase selection. For each problem, \underline{underline} indicates significant improvement over the other two selection methods at $p < 0.05$ based on a pairwise chi-square test with Holm correction \cite{R}, or a pairwise Fisher's exact test with Holm correction if any number of successes is below 5 \cite{fmsb}. The columns ``Lex$-$Tourn'' and ``Lex$-$IFS'' give the differences in success rate (successful runs divided by total runs) between lexicase and the other two settings. The columns ``Lex$-$Tourn CI'' and ``Lex$-$IFS CI'' give 95\% confidence intervals of the differences in success rate. The ``Size'' column indicates the smallest size of any simplified solution program.}
\label{tableResults}
\rowcolors{3}{Gray}{white}
\begin{tabular}{lrrr|rrrr|r}
\toprule
Problem & Tourn & IFS & Lex & Lex$-$Tourn & Lex$-$Tourn CI & Lex$-$IFS & Lex$-$IFS CI & Size \tabularnewline
\midrule
Number IO                  & 68      & 72  & \underline{98} & $0.30$ & $[0.19, 0.41]$ & $0.26$ & $[0.16, 0.36]$ & 5 \tabularnewline
Small Or Large             & 3       & 3   & 5         & $0.02$ & $[-0.04, 0.08]$ & $0.02$ & $[-0.04, 0.08]$ & 27 \tabularnewline
For Loop Index             & 0       & 0   & 1      & $0.01$ & $[-0.02, 0.04]$ & $0.01$ & $[-0.02, 0.04]$ & 21 \tabularnewline
Compare String Lengths     & 3       & 6   & 7      & $0.04$ & $[-0.03, 0.11]$ & $0.01$ & $[-0.07, 0.09]$ & 11 \tabularnewline
Double Letters             & 0       & 0   & 6  & $0.06$ & $[0.00, 0.12]$ & $0.06$ & $[0.00, 0.12]$ & 20 \tabularnewline
Collatz Numbers            & 0       & 0   & 0        &   $0$ & $-$ & $0$ & $-$ &  \tabularnewline
Replace Space with Newline & 8       & 16  & \underline{51}       & $0.43$ & $[0.31, 0.55]$ & $0.35$ & $[0.22, 0.48]$ & 9 \tabularnewline
String Differences         & 0       & 0   & 0        & $0$ & $-$ & $0$ & $-$ &  \tabularnewline
Even Squares               & 0       & 0   & 2        & $0.02$ & $[-0.02, 0.06]$ & $0.02$ & $[-0.02, 0.06]$ & 37 \tabularnewline
Wallis Pi                  & 0       & 0   & 0        &   $0$ & $-$ & $0$ & $-$ &  \tabularnewline
String Lengths Backwards   & 7       & 10  & \underline{66}       & $0.59$ & $[0.47, 0.71]$ & $0.56$ & $[0.44, 0.68]$ & 9 \tabularnewline
Last Index of Zero         & 8       & 4   & \underline{21}       & $0.13$ & $[0.02, 0.24]$ & $0.17$ & $[0.07, 0.27]$ & 5 \tabularnewline
Vector Average             & 14      & 13  & 16       & $0.02$ & $[-0.09, 0.13]$ & $0.03$ & $[-0.08, 0.14]$ & 7 \tabularnewline
Count Odds                 & 0       & 0   & \underline{8}        & $0.08$ & $[0.02, 0.14]$ & $0.08$ & $[0.02, 0.14]$ & 7 \tabularnewline
Mirror Image               & 46      & 64  & \underline{78}       & $0.32$ & $[0.18, 0.46]$ & $0.14$ & $[0.01, 0.27]$ & 4 \tabularnewline
Super Anagrams             & 0       & 0   & 0        & $0$ & $-$ & $0$ & $-$ &  \tabularnewline
Sum of Squares             & 2       & 0   & 6        & $0.04$ & $[-0.02, 0.10]$ & $0.06$ & $[0.00, 0.12]$ & 7 \tabularnewline
Vectors Summed             & 0       & 0   & 1        & $0.01$ & $[-0.02, 0.04]$ & $0.01$ & $[-0.02, 0.04]$ & 11 \tabularnewline
X-Word Lines               & 0       & 0   & \underline{8}        & $0.08$ & $[0.02, 0.14]$ & $0.08$ & $[0.02, 0.14]$ & 15 \tabularnewline
Pig Latin                  & 0       & 0   & 0        &   $0$ & $-$ & $0$ & $-$ &  \tabularnewline
Negative To Zero           & 10      & 8   & \underline{45}       & $0.35$ & $[0.23, 0.47]$ & $0.37$ & $[0.25, 0.49]$ & 8 \tabularnewline
Scrabble Score             & 0       & 0   & 2        & $0.02$ & $[-0.02, 0.06]$ & $0.02$ & $[-0.02, 0.06]$ & 14 \tabularnewline
Word Stats                 & 0       & 0   & 0        & $0$ & $-$ & $0$ & $-$ &  \tabularnewline
Checksum                   & 0       & 0   & 0        &  $0$ & $-$ & $0$ & $-$ &  \tabularnewline
Digits                     & 0       & 1   & 7        & $0.07$ & $[0.01, 0.13]$ & $0.06$ & $[0.00, 0.12]$ & 20 \tabularnewline
Grade                      & 0       & 0   & 4        & $0.04$ & $[-0.01, 0.09]$ & $0.04$ & $[-0.01, 0.09]$ & 52 \tabularnewline
Median                     & 7       & 43  & 45       & $0.38$ & $[0.26, 0.50]$ & $0.02$ & $[-0.13, 0.17]$ & 10 \tabularnewline
Smallest                   & 75      & \underline{98}  & 81       & $0.06$ & $[-0.06, 0.18]$ & $-0.17$ & $[-0.26, -0.08]$ & 8 \tabularnewline
Syllables                  & 1       & 7   & 18       & $0.17$ & $[0.08, 0.26]$ & $0.11$ & $[0.01, 0.21]$ & 14 \tabularnewline
\midrule
\rowcolor{white} Problems Solved          & 13       & 13      & 22 & & & & &   \\
\bottomrule
\end{tabular}
\end{table*}


Table \ref{tableResults} gives the results of our parent selection experiment. Over the 29 problems, PushGP with lexicase selection produced at least one successful run on nine more problems than either tournament selection or IFS. Additionally, there were 8 problems where lexicase selection achieved a significantly higher number of successful runs than the other two, where IFS showed significant improvement on just one problem and tournament selection none. Similarly, the confidence intervals of the difference in success rate between lexicase and tournament or IFS generally show neutral to positive effects of lexicase. These results strongly indicate the utility of lexicase selection for general program synthesis problems.

The data in Table \ref{tableResults} only reflect solutions that generalize by achieving zero error on the unseen test set. Some problems seem to lend themselves to generalization more than others; for example, PushGP using lexicase selection found 14 programs with zero error on the training set for the Super Anagrams problem, none of which generalized to the test set. For lexicase selection, five problems resulted in 20 or more runs that passed the training set that did not generalize (Small Or Large,
Compare String Lengths,
Last Index of Zero,
Negative To Zero, and
Median),
and five problems had between 10 and 20 runs that did not generalize (String Lengths Backwards,
Mirror Image,
Digits,
Smallest, and
Super Anagrams).
These 10 problems show an important area for future study: how to evolve programs that generalize to unseen data for general program synthesis problems. Among these problems are the only five in the suite that give a correct/incorrect binary error as fitness in our implementation: Compare String Lengths, Mirror Image, Super Anagrams, Median, and Smallest. This shows the difficulty of evolving general programs based entirely on correctness of output, and suggests that these problems might be better tackled if they can be transformed into problems with more informative error functions.

%Problems with >= 20 non-generalizing using lexicase:
%Small Or Large
%Compare String Lengths
%Last Index of Zero
%Negative To Zero
%Median
%
%Problems with [10, 20] non-generalizing using lexicase:
%String Lengths Backwards
%Mirror Image
%Digits
%Smallest
%Super Anagrams (none generalize)

With regards to the problems themselves, this experiment illustrates the ability of this benchmark suite to provide useful comparisons between multiple systems or parameter settings. By looking at the number of problems solved by each technique, and how often each technique showed significant improvements over the others, we can clearly see that lexicase selection increases PushGP's ability to solve general program synthesis problems compared to tournament selection and IFS. The main goal of a benchmark suite is to support this type of experiment. Additionally, some problems in the suite were solved frequently by each system, whereas others were solved infrequently or not at all. This range of difficulties permits the suite to be useful for a variety of experiments, and allows it to remain relevant as program synthesis systems improve.

Of the seven problems on which PushGP found no generalizing solution, most are not surprising in that they involve extensive use of multiple programming constructs, the linking of many distinct steps, or a deceptive fitness space where fitness improvements do not lead toward perfect programs. 
%The lexicase selection runs found 14 non-generalizing solutions to the Super Anagrams problem, suggesting that it may be solvable, but that issues of generalization must be addressed to reliably generate general solution. 
We have written solutions to each of the unsolved problems by hand to ensure that each problem is solvable within the constraints we put on the system and instruction set.


The last column in Table \ref{tableResults} gives the size (in instructions) of the  smallest simplified solution program. Here, we've used post-run simplification to automatically reduce the sizes of solution programs without changing their semantics on the training data \cite{Spector:2014:GECCOcomp}. While this hill-climbing simplification is not guaranteed to find the smallest semantically equivalent program, it reliably removes excess code, leaving the core functionality of the program \cite{Spector:2014:GECCOcomp}. The simplified program sizes present a reasonable proxy for the smallest solution program for each problem (using our instruction sets). While some problems can be solved with programs containing fewer than 10 instructions, none would likely be found using brute-force search over our instruction sets within the number of program evaluations allowed here. Searching over size 5 programs using the Number IO instruction set would require evaluating over 7 billion programs, much more than the 5 million we used in our GP runs. Other problems have smallest known solutions of over 20 instructions using instruction sets with more than 100 instructions, to our knowledge beyond the reach of all other program synthesis systems.

% Maybe this paragraph should conclude with something overarching about how these program sizes indicate these problems are difficult? Or is that implied?


%(Should we give the minimum size of a solution found by GP?
%probably should use simplified programs.
%gives idea of how large would need to search with something like brute-force search.)
% -- probably not enough space, though it's interesting. I looked into it, and minimum sizes tend to be between 6 and 20, though a few were higher up to 53. This is in Push points (i.e. the count-points function), since it is looking at simplified Push programs.

%I mean the sizes of the smallest simplified generalizing programs for each problem. I've scraped these sizes for the lexicase runs in the light green columns here. I think it's interesting in that it shows that a few of the problems have solution programs to be conceivably findable by brute-force search (probably only those with program sizes less than ~7, depending on the instruction set size). For example, the smallest program size with a small instruction set in our runs is for the Number IO problem, which found a solution with 6 instructions with an instruction set of size 50. Brute force testing every program of size 6 would require testing 6^50 programs on our 25 training cases, needing at most 3.9 × 10^11 program evaluations. We limited our runs to 5 * 10^5 evaluations, so much fewer. I'm sure other analytic synthesis methods can do much better than brute force, but that's a lot of ground to make up even on the simplest problem here. On the problems with smallest known solutions with 20+ instructions out of a 100+ instruction set, I doubt most analytic methods have a chance.
%
%Anyway, the reason I'm going into all of this is because one thing I think is important to emphasize in this paper that I'm not sure we've emphasized enough is that these problems use significantly bigger instruction sets and require significantly larger solution programs than other automatic program synthesis results I've seen, both inside and outside of GP. This is important for pushing the field forward and making sure we're not just using toy problems. I think that should be one of the big messages here, and showing that the problems require larger solution programs is part of that message.
%
%As for actually fitting something into the paper, one option is to add another column to the results table showing minimum sizes. I'm not sure if that would actually fit, and might be overkill. The other option is to have a short paragraph summarizing the data, saying things like "4 problems had smallest solutions between 5 and 10 instructions long, ...". I guess a third way would be a small table or figure that showed the summarized data. I'll think about this as I work on the paper today.



\section{Conclusions}

We have presented a suite of $29$ general program synthesis benchmark problems, systematically selected from sources of introductory computer science programming problems. Through exposition and experimentation, we have demonstrated the potential utility of this suite to assess the capabilities of program synthesis systems. We expect that the application of this suite can help advance multiple fields of automatic program synthesis, including genetic programming, that have long employed simple benchmark problems not attuned to potential real-world applications.


%We also hope to reinvigorate the use of genetic programming for general program synthesis, as most of its recent applications come in the form of small, domain-specific problems.



%We have presented a suite of $29$ general program synthesis benchmark problems, systematically selected from sources of introductory computer science programming problems. 
%The problems are appropriate for experiments with any program synthesis system driven by input/output examples. 
%We presented the criteria that we used to select the problems, we described the chosen problems in natural language, and we outlined the additional decisions that must be made in order to apply a program synthesis system to these problems. We have also provided recommendations for analysis of results of program synthesis experiments using our benchmarks.
%
%As an illustrative example we presented the results of an experiment that used the benchmarks to assess the utility of three different parent selection methods in the PushGP system. % \cite{spector:2002:GPEM, 1068292}.
%The results of the specific experiment strongly suggest that lexicase selection %\cite{Helmuth:2014:ieeeTEC}
% is more useful than either standard tournament selection or implicit fitness sharing %\cite{McKay:2000:GECCO,Krawiec:2013:EvoIASP}
% in this context. The more general lesson of this experiment, however, is that the problems in the presented benchmark suite vary in difficulty, and that they can be useful for assessing the capabilities of a program synthesis system.




%ACKNOWLEDGMENTS are optional
\section{Acknowledgments}

Thanks to the members of the Hampshire College Computational Intelligence Lab, Nicholas Freitag McPhee, Yuriy Brun, and David Jensen for discussions that helped to improve the work described in this paper, to Josiah Erikson for systems support, and to Hampshire College for support for the Hampshire College Institute for Computational Intelligence. This material is based upon work supported by the National Science Foundation under Grants No. 1017817, 1129139, and 1331283. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the authors and do not necessarily reflect the views of the National Science Foundation.


%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{gpBenchmarksReferences}  % sigproc.bib is the name of the Bibliography in this case
% You must have a proper ``.bib'' file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
%APPENDICES are optional
%\balancecolumns
%\appendix
%%Appendix A
%\section{Headings in Appendices}
%The rules about hierarchical headings discussed above for
%the body of the article are different in the appendices.
%In the \textbf{appendix} environment, the command
%\textbf{section} is used to
%indicate the start of each Appendix, with alphabetic order
%designation (i.e. the first is A, the second B, etc.) and
%a title (if you include one).  So, if you need
%hierarchical structure
%\textit{within} an Appendix, start with \textbf{subsection} as the
%highest level. Here is an outline of the body of this
%document in Appendix-appropriate form:
%\subsection{Introduction}
%\subsection{The Body of the Paper}
%\subsubsection{Type Changes and  Special Characters}
%\subsubsection{Math Equations}
%\paragraph{Inline (In-text) Equations}
%\paragraph{Display Equations}
%\subsubsection{Citations}
%\subsubsection{Tables}
%\subsubsection{Figures}
%\subsubsection{Theorem-like Constructs}
%\subsubsection*{A ' for the \TeX\ Expert}
%\subsection{Conclusions}
%\subsection{Acknowledgments}
%\subsection{Additional Authors}
%This section is inserted by \LaTeX; you do not insert it.
%You just add the names and information in the
%\texttt{{\char'134}additionalauthors} command at the start
%of the document.
%\subsection{References}
%Generated by bibtex from your ~.bib file.  Run latex,
%then bibtex, then latex twice (to resolve references)
%to create the ~.bbl file.  Insert that ~.bbl file into
%the .tex source file and comment out
%the command \texttt{{\char'134}thebibliography}.
%% This next section command marks the start of
%% Appendix B, and does not continue the present hierarchy
%\section{More Help for the Hardy}
%The sig-alternate.cls file itself is chock-full of succinct
%and helpful comments.  If you consider yourself a moderately
%experienced to expert user of \LaTeX, you may find reading
%it useful but please remember not to change it.
%%\balancecolumns % GM June 2007
%% That's all folks!

\end{document}
