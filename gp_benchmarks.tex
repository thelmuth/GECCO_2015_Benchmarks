
%%%%%
% Some things will likely have to be cut. Here are some options. The number in [1,10] with each indicates the importance of the thing, with higher numbers being more important (and thus harder to cut).
%
% CUT 2. GP Parameters table - This takes up a lot of space. While this would be needed for exactly replicating our experiments, we could succinctly and vaguely explain the parameter ranges in text and point to the implementations for exact values.
%
% 7. Table of instruction types used with each problem - This table is huge (takes up a page). But, it adds a lot to the discussion of our implementation recommendations.
%
% PARED 3. Methods section - We might need to make this as brief as possible, with pointers to other papers (like our WC paper) for more details. 
%
% 5. Parts of the experiments section - This is currently pretty long considering it's not the focus of the paper.
%
% MOSTLY CUT 1-4. Some citations - Some citations probably aren't necessary. I've marked a few in the text, especially with regards to lexicase selection, where I've cited multiple papers where a single citation might suffice. Also when citing PushGP. Also maybe the fmsb package citation for R.
%
% 8. Discussion of generalization in Experiments - this seems useful, but might be cutable
%
%%%%%

\documentclass{sig-alternate}

\usepackage{tabulary}
\usepackage[hyphens]{url}
\usepackage{rotating}
\usepackage{underscore}

\usepackage{booktabs}
\usepackage[table]{xcolor}
\definecolor{Gray}{gray}{0.9}

\graphicspath{{./Figures/}}

\begin{document}
%
% --- Author Metadata here ---
\conferenceinfo{GECCO'15,} {July 11-15, 2015, Madrid, Spain.}
\CopyrightYear{2015}
\crdata{TBA}
\clubpenalty=10000
\widowpenalty = 10000
% --- End of Author Metadata ---

%      IntroProg Benchmark Suite for General Program Synthesis
\title{General Program Synthesis Benchmark Suite}

\numberofauthors{2} 

\author{
% 1st. author
\alignauthor
Author omitted\\
       \affaddr{.}\\
       \affaddr{.}\\
       \affaddr{.}\\
       \email{.}
% 2nd. author
\alignauthor
Author omitted\\
       \affaddr{.}\\
       \affaddr{.}\\
       \affaddr{.}\\
       \email{.}
}

\maketitle

\begin{abstract}
Recent interest in the development and use of non-trivial benchmark problems in genetic programming has highlighted a scarcity of useful general program synthesis (also called ``traditional programming'') benchmark problems. 
%Most genetic programming benchmark problems prescribe small, domain-specific instruction sets; general program synthesis instead requires the type of programming expected of human programmers using higher-level programming languages. Problems of this type require a range of programming ``skills'', such as the utilization of control flow and modularity and the employment of large, diverse instruction sets covering multiple data types and data structures. 
We present a suite of $29$ general program synthesis benchmark problems systematically selected from sources of introductory computer science programming problems. 
%While we primarily intend to use this benchmark suite with genetic programming systems, we designed it with sufficient generality for any program synthesis system driven by input/output examples. 
This suite should be suitable for experiments with any program synthesis system driven by input/output examples. 
We present results from illustrative experiments using our reference implementation of the problems in the PushGP genetic programming system. The results show that the problems in the suite vary in difficulty and can be useful for assessing the capabilities of a program synthesis system.
\end{abstract}

\category{I.2.2}{Artificial Intelligence}{Automatic Programming}[Program synthesis]

%% A category with the (minimum) three required fields
%\category{H.4}{Information Systems Applications}{Miscellaneous}
%%A category including the fourth, optional field follows...
%\category{D.2.8}{Software Engineering}{Metrics}[complexity measures, performance measures]

%\terms{Theory}

\keywords{program synthesis; genetic programming; benchmark}

\section{Introduction}

Several genetic programming (GP) researchers have highlighted the need for better benchmark problems to guide research in the field \cite{McDermott:2012:GECCO, White:2013:BGB:2441218.2441242, Woodward:2014:GECCOcomp}. While benchmarks have been proposed, few are for general programming problems (also called ``traditional'' or ``algorithmic'' programming problems) even though this category received the second highest level of interest in a recent community survey about the need for benchmarks \cite{White:2013:BGB:2441218.2441242}. 

Automating human programming has long been a goal of GP, as articulated for example in Koza's first book \cite{koza:book}. The purpose of a general program synthesis benchmark is to help researchers assess the ability of a system to automate human programming. Such problems should require a range of programming techniques including the use of control flow, modularity, and large, diverse instruction sets covering multiple data types and data structures. This contrasts with most existing benchmark problems used in GP and other program synthesis fields, which prescribe small, domain-specific instruction sets and assess a system's abilities only on a narrow range of programming techniques.

In this paper we present a suite of $29$ general program synthesis benchmark problems, systematically selected from sources of introductory computer science programming problems. While the problems are not particularly challenging for skilled human programmers, they are reasonably challenging for beginners and many are arguably too difficult for existing program synthesis systems, including GP. If our goal is to develop general program synthesis systems, using GP or other techniques, then these benchmark problems should be useful for assessing progress.

In the sections below we first discuss issues related to the use of our benchmarks to assess and compare systems. We then describe the criteria used to select problems and each of the $29$ problems that we selected. Next, we present example system-specific parameters for our reference implementation in the PushGP system \cite{spector:2002:GPEM, 1068292}, followed by the results of an illustrative experiment.


%- cite \cite{Woodward:2014:GECCOcomp} in the discussion of GP benchmarks
%- One of the main points of the \cite{Woodward:2014:GECCOcomp} paper is that benchmark problems should come from a distribution relevant to the class of problems you are interested in solving. Our class of problems is general programming problems. Since we (a) don't know how to sample from this class of problems, and (b) don't know if we'd be able to solve that difficult of problem anyway, we instead are providing a set of intro CS problems. By giving a large range of problems, we do get some sampling of the space. And by using intro CS problems, we are building toward larger general programming problems---a first step.


\section{Benchmark-based comparisons}


We designate the solution of a general program synthesis problem as a program that perfectly maps inputs to correct outputs. While one might argue that human-written software is often useful even if it has known bugs, the goal here is to pass all input/output tests. Therefore, we will not be interested in programs that are only approximately correct, as might be appropriate in the context of other problems for which GP is used, such as symbolic regression or classification. We therefore recommend that performance on the problems presented here be measured primarily in terms of success rates, quantifying how often a stochastic algorithm finds a successful program across a set of runs\footnote{For deterministic synthesis algorithms other measures must be used, such as whether a correct program is found within a set period of time.}. A more thorough argument for assessment in terms of success rates can be found in \cite{Helmuth:2014:GECCO}.
Furthermore, in order to be considered successful, a program must not only achieve zero error on all of the example data used to train the program (the ``training set''), but also on a set of withheld generalization data (the ``test set''). 
%Since we do not want to require formal specifications for the problem, this test set is the best way to test whether a program actually solves the problem or instead memorizes the training set.

%should we cite WC paragraph for having a more detailed discussion of these things somewhere in here? --> DONE: cited mid-paragraph above



%Statistical procedure -- maybe leave out? Would talk about chi-square tests and Fisher's exact test. (leaving out for now)

When using this benchmark suite to compare different settings within one system, we recommend limiting computation with a budget based on the maximum number of program evaluations allowed in a run. This ensures that the methods perform similar computational work. That said, it may nonetheless be difficult to justify fine-grained numerical comparisons among diverse techniques on these problems, as they may involve qualitatively different kinds of costs and each may be parameterized in radically different ways. In many cases, the most interesting question to ask vis-a-vis a particular system on a particular problem may just be whether the system can solve the problem at all, and if so,  whether it can solve it reasonably reliably. Nonetheless, we aim here to describe specifications that will allow for as much cross-system comparability as possible. % A lot of this paragraph is copied from a Lee email; it sounded good, so I kept it with minor editing.


\section{Problem selection criteria} \label{requirements}

In this section we describe the criteria we used when selecting problems for the benchmark suite, as well as the requirements for program synthesis systems to be applied to the problems. Several of our criteria overlap with those described in the GP benchmarks papers \cite{McDermott:2012:GECCO, White:2013:BGB:2441218.2441242}, such as being varied, relevant, realistically difficult, representation-independent, and precisely defined. 
%Other proposed requirements have less relevance to this set of problems because of the general program synthesis domain we target.

This benchmark suite is designed for systems that use example inputs and their corresponding outputs as the specifications for desired programs. In the context of GP, we call the input/output pairs \textit{fitness cases} for the problem. Thus, a problem must be defined on a range of inputs that have known correct outputs; it cannot simply specify the calculation of a single value. For example, a problem that requires the program to calculate the number of prime numbers less than 1000 would not qualify, since it only has one answer; but, a similar problem that requires the program to calculate the number of prime numbers less than an input integer $n$ would meet this requirement, since we could then provide example inputs for $n$ and their corresponding outputs. This requirement also ensures that fitness cases can be generated to fill the training and test set, as required to ensure generalization of successful programs.

Problems in the suite should present challenges typical of real programming tasks. 
%The goal of a benchmark problem is to measure the characteristics of a system on a problem that mimics some aspects of the real applications on which it is expected to function. 
This criterion leads us to choose problems that require a range of programming constructs and data types. Ideally, the problems should require a variety of sizes and shapes for solution programs, not just artificially small programs. 

The benchmarks should not be biased toward a particular method of synthesis; it should be possible to attempt to solve them using various GP systems as well as analytic and search-based program synthesis systems. Since systems generate programs in a variety of languages, problems that require a specific language feature or non-standard data type (such as Java objects) should be avoided.

We have chosen our problems from pre-existing sources of introductory programming problems. By borrowing from these external sources, and using all problems from these sources that meet the requirements described above, we aim to avoid biasing the selection of problems.

%[BELONG ELSEWHERE? BETTER TRANSITION? OR JUST REMOVE?]
%For a synthesis system to be applicable to the problems in this suite, it must take input/output examples as program specifications. It must be able to produce programs that manipulate the data types necessary to solve the problems, which includes the ability to print outputs and return functional results. Any synthesis system that meets these requirements may be applied to these problems.


\section{Problem Descriptions} \label{descriptionsSection}
% Other section title options: Problems or The Problems or The Benchmark Problems

We used two sources for problems: iJava \cite{iJava}, an interactive textbook for introductory computer science, and IntroClass \cite{ManyBugsAndIntroClass, Brun13TRgptest}, a set of problems originally used as benchmarks for automatic program repair. Below we describe each of these sources in further detail, along with the problems selected from each source. All problems, unless stated otherwise, use functional arguments as inputs and functional outputs as return values.

\subsection{iJava}

%In this section, we will describe the problems from iJava \cite{iJava, Moll:2011:IOI:1968521.1968535}. 

iJava is an interactive introductory computer science text that contains a number of automatically graded programming problems \cite{iJava, Moll:2011:IOI:1968521.1968535}. These problems work well for general program synthesis from examples, since they are often graded by testing programs against a range of inputs.

Some sets of problems in iJava meet our criteria but test similar programming techniques; for each such set, we chose one representative problem from the group, ensuring a reasonable distribution of required programming techniques. Below, we present a natural language description as might be given to human programmers for the 23 problems chosen from iJava, and provide the question or project number associated with the problem in iJava 3.1.

\begin{enumerate}
\item
\textbf{Number IO (Q 3.5.1)}
Given an integer and a float, print their sum.

\item
\textbf{Small or Large (Q 4.6.3)}
Given an integer $n$ in the range $[-10000, 10000]$, print ``small'' if $n < 1000$ and ``large'' if $n \ge 2000$ (and nothing if $1000 \le n < 2000$).

\item
\textbf{For Loop Index (Q 4.11.7)}
Given 3 integer inputs $start, finish,$ and $stepSize$, print the integers in the sequence
\begin{align*}
n_0 &= start \\
n_i &= n_{i-1} + stepSize
\end{align*}
for each $n_i < finish$, each on their own line.

\item
\textbf{Compare String Lengths (Q 4.11.13)}
Given three strings $n1$, $n2$, and $n3$, return true if $length(n1) < length(n2) < length(n3)$, and false otherwise.

\item
\textbf{Double Letters (Project 4.1)}
Given a string, print the string, doubling every letter character, and tripling every exclamation point. All other non-alphabetic and non-exclamation characters should be printed a single time each.

\item
\textbf{Collatz Numbers (Project 4.2)}
Given an integer, find the number of terms in the Collatz sequence starting from that integer.

\item
\textbf{Replace Space with Newline (Project 4.3)}
Given a string input, print the string, replacing spaces with newlines. Also, return the integer count of the non-whitespace characters. The input string will not have tabs or newlines, but may have multiple spaces in a row.

\item
\textbf{String Differences (Project 4.4)}
Given 2 strings (without whitespace) as input, find the indices at which the strings have different characters, stopping at the end of the shorter one. For each such index, print a line containing the index as well as the character in each string. For example, if the strings are ``dealer'' and ``dollars'', the program should print:
\texttt{\\*
\hspace*{1cm}1 e o \\*
\hspace*{1cm}2 a l \\*
\hspace*{1cm}4 e a
}

\item
\textbf{Even Squares (Q 5.4.1)}
Given an integer $n$, print all of the positive even perfect squares less than $n$ on separate lines.

\item
\textbf{Wallis Pi (Project 6.4))}
John Wallis gave the following infinite product that converges to $\pi/4$:
\[
\frac{2}{3}\times \frac{4}{3}\times \frac{4}{5}\times \frac{6}{5}\times \frac{6}{7}\times \frac{8}{7}\times \frac{8}{9}\times \frac{10}{9} \times ...
\]
Given an integer input $n$, compute an approximation of this product out to $n$ terms. Results are rounded to 5 decimal places.

\item
\textbf{String Lengths Backwards (Q 7.2.5)}
Given a vector of strings, print the length of each string in the vector starting with the last and ending with the first.

\item
\textbf{Last Index of Zero (Q 7.7.8)}
Given a vector of integers, at least one of which is 0, return the index of the last occurrence of 0 in the vector.

\item
\textbf{Vector Average (Q 7.7.11)}
Given a vector of floats, return the average of those floats. Results are rounded to 4 decimal places.

\item
\textbf{Count Odds (Q 7.7.12)}
Given a vector of integers, return the number of integers that are odd, without use of a specific \texttt{even} or \texttt{odd} instruction (but allowing instructions such as \texttt{mod} and \texttt{quotient}).

\item
\textbf{Mirror Image (Q 7.7.15)}
Given two vectors of integers, return true if one vector is the reverse of the other, and false otherwise.

\item
\textbf{Super Anagrams (Project 7.3)}
Given strings $x$ and $y$ of lowercase letters, return true if $y$ is a super anagram of $x$, which is the case if every character in $x$ is in $y$. To be true, $y$ may contain extra characters, but must have at least as many copies of each character as $x$ does.

\item
\textbf{Sum of Squares (Q 8.5.4)}
Given integer $n$, return the sum of squaring each integer in the range $[1, n]$.

\item
\textbf{Vectors Summed (Q 8.7.6)}
Given two equal-size vectors of integers, return a vector of integers that contains the sum of the input vectors at each index.

\item
\textbf{X-Word Lines (Project 8.1)}
Given an integer $X$  and a string that can contain spaces and newlines, print the string with exactly $X$ words per line. The last line may have fewer than $X$ words.

\item
\textbf{Pig Latin (Project 8.2)}
Given a string containing lowercase words separated by single spaces, print the string with each word translated to pig Latin. More specifically, if a word starts with a vowel, it should have ``ay'' added to its end; otherwise, the first letter is moved to the end of the word, followed by ``ay''.

\item
\textbf{Negative To Zero (Q 9.6.8)}
Given a vector of integers, return the vector where all negative integers have been replaced by 0.

\item
\textbf{Scrabble Score (Project 10.1)}
Given a string of visible ASCII characters, return the Scrabble score for that string. Each letter has a corresponding value according to normal Scrabble rules, and non-letter characters are worth zero.

\item
\textbf{Word Stats (Project 10.5)}
Given a file, print the number of words containing $n$ characters for $n$ from 1 to the length of the longest word, in the format:
\texttt{ \\
\hspace*{1cm}words of length 1: 12 \\
\hspace*{1cm}words of length 2: 3 \\
\hspace*{1cm}words of length 3: 0 \\
\hspace*{1cm}words of length 4: 5 \\
\hspace*{1cm}... \\
} %this looks terrible -- is there something better?
\noindent At the end of the output, print a line that gives the number of sentences and line that gives the average sentence length using the form:
\texttt{ \\
\hspace*{1cm}number of sentences: 4 \\
\hspace*{1cm}average sentence length: 7.452423455 \\
}
\noindent A word is any string of consecutive non-whitespace characters (including sentence terminators). Every file will contain at least one sentence terminator (period, exclamation point, or question mark). The average sentence length is the number of words in the file divided by the number of sentence terminator characters.

\end{enumerate}

\subsection{IntroClass}

%In this section, we will describe the problems from the IntroClass dataset \cite{ManyBugsAndIntroClass, Brun13TRgptest}. 

The set of 6 problems in the IntroClass dataset \cite{ManyBugsAndIntroClass, Brun13TRgptest} was designed for the purpose of benchmarking automatic software defect repair systems. As such, the authors of this dataset provide a number of buggy programs written by students trying to solve each problem, taken from students in an introductory computer science class. For the purposes of automatic program synthesis from scratch, we will use the problems themselves but not the accompanying buggy programs. 
%Since these problems were designed for automatic defect repair, they all can be tested on a range of inputs, and require outputs to be printed.
Each of these problems can be tested on a range of inputs, and each requires outputs to be printed.

\begin{enumerate}
\setcounter{enumi}{23}

\item
\textbf{Checksum}
Given a string, compute the integer values of the characters in the string, sum them, take the sum modulo 64, add the integer value of the space character, and then convert that integer back into its corresponding character (the checksum character). The program must print \texttt{Check sum is X}, where $X$ is replaced by the correct checksum character.

\item
\textbf{Digits}
Given an integer, print that integer's digits each on their own line starting with the least significant digit. A negative integer should have the negative sign printed before the most significant digit.

\item
\textbf{Grade}
Given 5 integers, the first four represent the lower numeric thresholds for achieving an A, B, C, and D, and will be distinct and in descending order. The fifth represents the student's numeric grade. The program must print \texttt{Student has a X grade.}, where $X$ is A, B, C, D, or F depending on the thresholds and their numeric grade.

\item
\textbf{Median}
Given 3 integers, print their median.

\item
\textbf{Smallest}
Given 4 integers, print the smallest of them.

\item
\textbf{Syllables}
Given a string containing symbols, spaces, digits, and lowercase letters, count the number of occurrences of vowels (a, e, i, o, u, y) in the string and print that number as $X$ in \texttt{The number of syllables is X}.

\end{enumerate}

\section{Synthesis Specifications} \label{synthProbSpec}
% Other title options: Synthesis Parameters, Data and Instructions


%The natural language descriptions of the benchmark problems in Section \ref{descriptionsSection} contain insufficient details to implement specifications for each desired program in a program synthesis system. In this section we discuss issues related to defining problems so that they are interpretable by program synthesis systems. These specifications will allow the benchmark problems to be implemented in a variety of systems and should be technique-independent, while ensuring that different implementations are solving the ``same problem''.

The natural language descriptions of the problems in Section \ref{descriptionsSection} do not provide all of the information needed to apply program synthesis systems to the problems. Here we provide the needed additional information, aiming to do so in a technique-independent and system-independent way.

\begin{table*}[t]
\centering
\caption{For each problem, the types of the inputs and outputs, and the limits imposed on the inputs. Any printed outputs should be printed by the program to standard output. The columns Train and Test indicate the recommended sizes of the training set and test set respectively.}
\label{testCasesTable}
%{\renewcommand{\arraystretch}{1}%
\rowcolors{3}{Gray}{white}
\begin{tabular}{>{\raggedright}p{3.5cm}  >{\raggedright}p{7.4cm} l rr}
\toprule
\textbf{Name} & \textbf{Inputs} & \textbf{Outputs} & \textbf{Train} & \textbf{Test} \\
\midrule
Number IO & integer in $[-100, 100]$, float in $[-100.0, 100.0]$ & printed float & 25 & 1000 \\
%\hline
Small Or Large & integer in $[-10000, 10000]$ & printed string & 100 & 1000 \\
%\hline
For Loop Index & integers \texttt{start} and \texttt{end} in $[-500, 500]$, \texttt{step} in $[1, 10]$ & printed integers & 100 & 1000 \\
%\hline
Compare String Lengths & 3 strings of length $[0, 49]$ & boolean & 100 & 1000 \\
%\hline
Double Letters & string of length $[0, 20]$ & printed string & 100 & 1000 \\
%\hline
Collatz Numbers & integer in $[1, 10000]$ & integer & 200 & 2000 \\
%\hline
Replace Space with Newline & string of length $[0, 20]$ & printed string, integer & 100 & 1000 \\
%\hline
String Differences & 2 strings of length $[0, 10]$ & printed string & 200 & 2000 \\
%\hline
Even Squares & integer in $[1, 9999]$ & printed string & 100 & 1000 \\
%\hline
Wallis Pi & integer in $[1, 200]$ & float & 150 & 50 \\
%\hline
String Lengths Backwards & vector of length $[0, 50]$ of strings of length $[0, 50]$ & printed string & 100 & 1000 \\
%\hline
Last Index of Zero & vector of integers of length $[1, 50]$ with each integer in $[-50, 50]$ & integer & 150 & 1000 \\
%\hline
Vector Average & vector of floats of length $[1,50]$ with each float in $[-1000.0, 1000.0]$ & float & 100 & 1000 \\
%\hline
Count Odds & vector of integers of length $[0,50]$ with each integer in $[-1000, 1000]$ & integer & 200 & 2000 \\
%\hline
Mirror Image & 2 vectors of integers of length $[0,50]$ with each integer in $[-1000, 1000]$ & boolean & 100 & 1000 \\
%\hline
Super Anagrams & 2 strings of length $[0, 20]$ & boolean & 200 & 2000 \\
%\hline
Sum of Squares & integer in $[1, 100]$ & integer & 50 & 50 \\
%\hline
Vectors Summed & 2 vectors of integers of length $[0,50]$ with each integer in $[-1000, 1000]$ & vector of integers & 150 & 1500 \\
%\hline
X-Word Lines & integer in $[1, 10]$, string of length $[0, 100]$ & printed string & 150 & 2000 \\
%\hline
Pig Latin & string of length $[0, 50]$ & printed string & 200 & 1000 \\
%\hline
Negative To Zero & vector of integers of length $[0,50]$ with each integer in $[-1000, 1000]$ & vector of integers & 200 & 2000 \\
%\hline
Scrabble Score & string of length $[0, 20]$ & integer & 200 & 1000 \\
%\hline
Word Stats & file containing $[1, 100]$ chars & printed string & 100 & 1000 \\
%\hline
Checksum & string of length $[0, 50]$ & printed string & 100 & 1000 \\
%\hline
Digits & integer in $[-9999999999, 9999999999]$ & printed integers & 100 & 1000 \\
%\hline
Grade & 5 integers in $[0, 100]$ & printed string & 200 & 2000 \\
%\hline
Median & 3 integers in $[-100, 100]$ & printed integer & 100 & 1000 \\
%\hline
Smallest & 4 integers in $[-100, 100]$ & printed integer & 100 & 1000 \\
%\hline
Syllables & string of length $[0, 20]$ & printed string & 100 & 1000\\
\bottomrule
\end{tabular}
\end{table*}

%Table \ref{testCasesTable} presents information related to the sets of training and test data for each problem. These recommendations, like the rest in this section, are not set in stone; instead, they present guidelines that should be followed where possible. Adhering to these guidelines closely will create results with more legitimate comparability to the results presented here. The table describes the data types of the inputs and outputs and gives reasonable ranges for program inputs. Note that some problems specify that outputs are printed to standard output, a requirement exhibited often in human-written code but rarely seen in automatic program synthesis previously. These problems explicitly required the printing of results in their original sources.

Table \ref{testCasesTable} presents recommendations regarding training and test data for each problem. While these are merely guidelines, and there may be good reasons to diverge from them when using different techniques or systems, adhering to these guidelines will clarify comparisons among techniques and systems. The table describes the data types of the inputs and outputs and gives reasonable ranges for program inputs. 

We also provide recommendations for numbers of cases to use in the training and test sets for each problem in Table \ref{testCasesTable}. For most problems, we recommend between 100 and 200 training cases, depending on the difficulty of the problem as well as the dimensionality of the input space. A few problems use fewer, either because they have limited input spaces or are simple enough to solve with fewer cases. The size of the test set used to test generalization to unseen data is usually recommended to be ten times as large as the training set; again, there are exceptions for problems with limited input spaces. The method of producing the training and test cases is system-specific; we recommend a combination of hand-chosen edge cases with randomly generated cases, and will describe our method in more detail in Section \ref{systemParamsSection}.

% Table 2 prior location

The question of which instructions to make available for a synthesis system to use for each problem is a complex one. It is important to not cherry pick a small set of instructions that are known to be sufficient to solve a problem; such a selection may be difficult for a real-world problem, where it might not be clear which instructions will be useful. On the other hand, using all available instructions for every problem expands the search space and may make problems more difficult than necessary. We recommend a compromise between these approaches
% by first determining what data types are required for each instruction in the instruction set, and then deciding which data types could be useful in solving each problem and using the relevant instructions. 
in which one first determines which data types are likely to be useful for solving the problem and then uses all instructions that operate on those data types.
%For example, an instruction that compares the equality of two integers and returns a boolean would be included if the problem could potentially make use of integers and booleans. 
By specifying only the data type requirements for a problem, we can limit the number of instructions without cherry picking. 


\section{System-Specifc Parameters} \label{systemParamsSection}

Whereas Section \ref{synthProbSpec} gave technique-independent recommendations for specifying the benchmark problems for a synthesis system, this section will give more detail about the system-specific parameters and decisions that must be made in order to implement these problems in a given program synthesis system. Here we will focus on our implementation in the PushGP genetic programming system, but we emphasize that this is just one possible approach and one possible implementation, and that the problems here could be used in any system that meets the requirements in Section \ref{requirements}.


PushGP evolves programs in Push, a stack-based programming language designed specifically for GP \cite{spector:2002:GPEM, 1068292}. % Maybe remove one or two of these citations?
%PushGP has many features useful for general program synthesis, such as supporting multiple data types, control flow, and the use of input/output examples as specifications. 
The reference implementation of our problems in PushGP can be found on GitHub.\footnote{Omitted for blind review.} In the rest of this section, we will describe some of the major decisions necessary for implementing these benchmark problems in this environment. As we will not have space to discuss every parameter and implementation choice, the problem files in the reference implementation can be used to illustrate the details we omit.

When generating training and testing data, we use a combination of hand-picked edge cases that remain constant across runs and randomly generated inputs that vary across runs. For each problem, we specify one or more ``data domains'' \cite{Helmuth:2014:GECCO}, which consist of either a set of hard-coded inputs or a random input generator, as well as the number of training and test cases that should come from each domain. Details on using data domains can be found in \cite{Helmuth:2014:GECCO}, and our reference implementation gives our choices for data domains for each problem.

When using this benchmark suite with GP, we need not only the input/output cases, but also a method of measuring how well a particular program performs on each case---the \textit{fitness function}. 
%Fitness functions for these problems must not only match their respective output types, but must also give reasonable measurement of program performance. Still, we can present some generalities of our chosen fitness functions before pointing to the reference implementation for details.
Many of the problems in this suite print results to standard output, and we generally treat these outputs as strings and use Levenshtein distance (a measure of string edit distance) as the fitness function. Other problems produce numeric outputs, either returned or printed; for these problems we use absolute error for fitness, parsing printed numbers when necessary and possible. Some problems produce boolean values, or are best measured by a simple binary right or wrong; here, we use a fitness of 0 for right and 1 for wrong. Finally, some problems require problem-tailored fitness functions, such as vector edit distance or string formatting requirements.

For some problems we found it appropriate to use multiple error [FITNESS?] functions per case. For example, the Replace Space With Newline problem requires both a printed string and a returned integer. For problems like this, we produce multiple fitness values for a single case. Additionally, we find that PushGP performs better on other problems when we use more than one fitness value per case, even where not strictly necessary. For example, we found no solutions to the X-Word Lines problem when only using Levenshtein distance as the fitness function, but found solutions when adding additional error functions for the number of newline characters and summed errors of differences in number of words compared to correct. When using multiple error values for a single training case, we treat each error value as a separate case when the parent selection method requires it; in tournament selection, we simply sum all errors.


\begin{table*}%[t]
\centering
\caption{Instructions and data types used in our PushGP implementation of each problem. The column ``\# Instructions'' reports the number of instructions, terminals, and ERCs used for each problem. The middle columns show which data types were used for each problem. For example, the Number IO problem used all instructions relevant to integers, floats, and printing. The last column lists the constants and ERCs used for the problem. Here, char constants are represented in the Clojure style, starting with a backslash, and strings are surrounded by double quotation marks. The ``Problems Using Type'' row simply counts how many problems use each data type. The ``Instructions for Type'' row shows the number of Push instructions that primarily use each data type; some use multiple types but are only counted once.}
\label{tableDataTypes}
\rowcolors{3}{Gray}{white}
\begin{tabular}{>{\raggedright}p{3.1cm}cccccccccccc>{\raggedright}p{5.5cm}}
%\hline
\toprule
\textbf{Problem} & \begin{sideways}\textbf{\# Instructions} \- \end{sideways} & \begin{sideways}\textbf{exec}\end{sideways} & \begin{sideways}\textbf{integer}\end{sideways} & \begin{sideways}\textbf{float}\end{sideways} & \begin{sideways}\textbf{boolean}\end{sideways} & \begin{sideways}\textbf{char}\end{sideways} &  \begin{sideways}\textbf{string}\end{sideways} & \begin{sideways}\textbf{vector of integers} \- \end{sideways} & \begin{sideways}\textbf{vector of floats}\end{sideways} & \begin{sideways}\textbf{vector of strings}\end{sideways} & \begin{sideways}\textbf{print}\end{sideways} & \begin{sideways}\textbf{file input}\end{sideways} & \textbf{Terminals (besides inputs)} \tabularnewline
%\hline
%\hline
\midrule
Number IO                  & 50              &      & x       & x     &         &      &        &                    &                  &                   & x     &            & integer ERC, float ERC                                                                                                                                                                                                      \tabularnewline
%\hline
Small Or Large             & 103             & x    & x       &       & x       &      & x      &                    &                  &                   & x     &            & ``small'', ``large'', integer ERC                                                                                                                                                                                               \tabularnewline
%\hline
For Loop Index             & 74              & x    & x       &       & x       &      &        &                    &                  &                   & x     &            &                                                                                                                                                                                                                             \tabularnewline
%\hline
Compare String Lengths     & 98              & x    & x       &       & x       &      & x      &                    &                  &                   &       &            & boolean ERC                                                                                                                                                                                                                 \tabularnewline
%\hline
Double Letters             & 132             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & \textbackslash !                                                                                                                                                                                                            \tabularnewline
%\hline
Collatz Numbers            & 102             & x    & x       & x     & x       &      &        &                    &                  &                   &       &            & 0, 1, integer ERC                                                                                                                                                                                                           \tabularnewline
%\hline
Replace Space with Newline & 135             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & \textbackslash space, \textbackslash newline, string ERC, char ERC                                                                                                                                                          \tabularnewline
%\hline
String Differences         & 135             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & \textbackslash space, \textbackslash newline, integer ERC                                                                                                                                                                   \tabularnewline
%\hline
Even Squares               & 72              & x    & x       &       & x       &      &        &                    &                  &                   & x     &            &                                                                                                                                                                                                                             \tabularnewline
%\hline
Wallis Pi                  & 103             & x    & x       & x     & x       &      &        &                    &                  &                   &       &            & 2 integer ERCs, 2 float ERCs                                                                                                                                                                                                \tabularnewline
%\hline
String Lengths Backwards   & 134             & x    & x       &       & x       &      & x      &                    &                  & x                 & x     &            & integer ERC                                                                                                                                                                                                                 \tabularnewline
%\hline
Last Index of Zero         & 101             & x    & x       &       & x       &      &        & x                  &                  &                   &       &            & 0                                                                                                                                                                                                                           \tabularnewline
%\hline
Vector Average             & 88              & x    & x       & x     &         &      &        &                    & x                &                   &       &            &                                                                                                                                                                                                                             \tabularnewline
%\hline
Count Odds                 & 104             & x    & x       &       & x       &      &        & x                  &                  &                   &       &            & 0, 1, 2, integer ERC                                                                                                                                                                                                        \tabularnewline
%\hline
Mirror Image               & 102             & x    & x       &       & x       &      &        & x                  &                  &                   &       &            & boolean ERC                                                                                                                                                                                                                 \tabularnewline
%\hline
Super Anagrams             & 129             & x    & x       &       & x       & x    & x      &                    &                  &                   &       &            & boolean ERC, char ERC, integer ERC                                                                                                                                                                                          \tabularnewline
%\hline
Sum of Squares             & 71              & x    & x       &       & x       &      &        &                    &                  &                   &       &            & 0, 1, integer ERC                                                                                                                                                                                                           \tabularnewline
%\hline
Vectors Summed             & 68              & x    & x       &       &         &      &        & x                  &                  &                   &       &            & {[}{]}, integer ERC                                                                                                                                                                                                         \tabularnewline
%\hline
X-Word Lines               & 134             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & \textbackslash newline, \textbackslash space                                                                                                                                                                                \tabularnewline
%\hline
Pig Latin                  & 141             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & ``ay'', \textbackslash space, \textbackslash a, \textbackslash e, \textbackslash i, \textbackslash o, \textbackslash u, ``aeiou'', string ERC, char ERC                                                                         \tabularnewline
%\hline
Negative To Zero           & 102             & x    & x       &       & x       &      &        & x                  &                  &                   &       &            & 0, {[}{]}                                                                                                                                                                                                                   \tabularnewline
%\hline
Scrabble Score             & 158             & x    & x       &       & x       & x    & x      & x                  &                  &                   &       &            & vector containing Scrabble values (indexed by ASCII values)                                                                                                                                                                 \tabularnewline
%\hline
Word Stats                 & 281             & x    & x       & x     & x       & x    & x      & x                  & x                & x                 & x     & x          & \textbackslash ., \textbackslash ?, \textbackslash !, \textbackslash space, \textbackslash tab, \textbackslash newline, {[}{]}, ``words of length '', ``: '', ``number of sentences: '', ``average sentence length: '', integer ERC \tabularnewline
%\hline
Checksum                   & 136             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & ``Check sum is '', \textbackslash space, 64, integer ERC, char ERC                                                                                                                                                            \tabularnewline
%\hline
Digits                     & 133             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & \textbackslash newline, integer ERC {[}-10, 10{]}                                                                                                                                                                           \tabularnewline
%\hline
Grade                      & 112             & x    & x       &       & x       &      & x      &                    &                  &                   & x     &            & ``Student has a '', `` grade.'', ``A'', ``B'', ``C'', ``D'', ``F'', integer ERC                                                                                                                                                           \tabularnewline
%\hline
Median                     & 75              & x    & x       &       & x       &      &        &                    &                  &                   & x     &            & integer ERC                                                                                                                                                                                                                 \tabularnewline
%\hline
Smallest                   & 76              & x    & x       &       & x       &      &        &                    &                  &                   & x     &            & integer ERC                                                                                                                                                                                                                 \tabularnewline
%\hline
Syllables                  & 141             & x    & x       &       & x       & x    & x      &                    &                  &                   & x     &            & ``The number of syllables is '', ``aeiouy'', \textbackslash a, \textbackslash e, \textbackslash i, \textbackslash o, \textbackslash u, \textbackslash y, char ERC, string ERC                                                   \tabularnewline
%\hline
%\hline
\midrule
\rowcolor{white} Problems Using Type                      &                 & 28   & 29      & 5     & 26      & 11   & 15     & 7                  & 2                & 2                 & 17    & 1          &                                                                                                                                                                                                                             \tabularnewline
%\hline
\rowcolor{white} Instructions for Type     &                 & 28   & 28      & 31    & 19      & 17   & 39     & 31                 & 31               & 31                & 10    & 4          &                                                                                                                                                                                                                             \tabularnewline
\bottomrule
%\hline
\end{tabular}
\end{table*}

As discussed in Section \ref{synthProbSpec}, we have chosen to specify the data types relevant to each problem, and then include all instructions that use those data types in each problem's instruction set. Table \ref{tableDataTypes} presents the Push data types we chose for each problem. The ``exec'' column signifies instructions that use Push's exec stack, which typically perform control flow manipulations such as conditionals, iteration, and subfunctions defined through tagging \cite{Spector:2011:GECCO}. The ``print'' column includes instructions that print data to standard output, and ``file input'' includes a small set of file reading instructions. 
%The data types for instructions will vary per system, and instruction categories should not be constrained to those used here.

Table \ref{tableDataTypes} also gives the terminals used for each problem, which encompass constants and ephemeral random constants (ERCs). ERCs allow for the creation of random constants in randomly generated code during initialization and mutation. We used problem-specific constant ranges, which can be found in the reference implementation.
The second column in Table \ref{tableDataTypes} gives the number of instructions and terminals we used in our implementation of the benchmark problems in PushGP. 
%The number of instructions used in other implementations of these problems will vary depending on the language in which programs are synthesized. These instructions should include a wide range of general purpose programming instructions similar to those used in modern high-level programming languages. The high numbers of instructions used for these general programming problems differs from most prior applications of GP and other program synthesis techniques, which often use small, domain-specific instruction sets.

%\begin{table}[h]
%\centering
%\caption{GP Parameters}
%\label{tableGPParameters}
%\begin{tabular}{|>{\raggedright}m{2.5cm} | >{\raggedleft}p{0.6cm} >{\raggedleft}p{0.8cm} >{\raggedleft}p{0.6cm}   >{\raggedleft}p{1.6cm}|}
%\hline
%Problem                    & Max Prog Size & Eval Limit & Max Gens & Program Evaluation Budget \tabularnewline
%\hline
%Number IO                  & 200           & 200            & 200      & 5,000,000                 \tabularnewline
%Small Or Large             & 200           & 300            & 300      & 30,000,000                \tabularnewline
%For Loop Index             & 300           & 600            & 300      & 30,000,000                \tabularnewline
%Compare String Lengths     & 400           & 600            & 300      & 30,000,000                \tabularnewline
%Double Letters             & 800           & 1600           & 300      & 30,000,000                \tabularnewline
%Collatz Numbers            & 600           & 15000          & 300      & 60,000,000                \tabularnewline
%Replace Space with Newline & 800           & 1600           & 300      & 30,000,000                \tabularnewline
%String Differences         & 1000          & 2000           & 300      & 60,000,000                \tabularnewline
%Even Squares               & 400           & 2000           & 300      & 30,000,000                \tabularnewline
%Wallis Pi                  & 600           & 8000           & 300      & 45,000,000                \tabularnewline
%String Lengths Backwards   & 300           & 600            & 300      & 30,000,000                \tabularnewline
%Last Index of Zero         & 300           & 600            & 300      & 45,000,000                \tabularnewline
%Vector Average             & 400           & 800            & 300      & 30,000,000                \tabularnewline
%Count Odds                 & 500           & 1500           & 300      & 60,000,000                \tabularnewline
%Mirror Image               & 300           & 600            & 300      & 30,000,000                \tabularnewline
%Super Anagrams             & 800           & 1600           & 300      & 60,000,000                \tabularnewline
%Sum of Squares             & 400           & 4000           & 300      & 15,000,000                \tabularnewline
%Vectors Summed             & 500           & 1500           & 300      & 45,000,000                \tabularnewline
%X-Word Lines               & 800           & 1600           & 300      & 45,000,000                \tabularnewline
%Pig Latin                  & 1000          & 2000           & 300      & 60,000,000                \tabularnewline
%Negative To Zero           & 500           & 1500           & 300      & 60,000,000                \tabularnewline
%Scrabble Score             & 1000          & 2000           & 300      & 60,000,000                \tabularnewline
%Word Stats                 & 1000          & 6000           & 300      & 30,000,000                \tabularnewline
%Checksum                   & 800           & 1500           & 300      & 30,000,000                \tabularnewline
%Digits                     & 300           & 600            & 300      & 30,000,000                \tabularnewline
%Grade                      & 400           & 800            & 300      & 60,000,000                \tabularnewline
%Median                     & 200           & 200            & 200      & 20,000,000                \tabularnewline
%Smallest                   & 200           & 200            & 200      & 20,000,000                \tabularnewline
%Syllables                  & 800           & 1600           & 300      & 30,000,000                \tabularnewline
%\hline
%\end{tabular}
%\end{table}

%When considering system parameters for GP specifically, 
We keep most of our PushGP system parameters constant across all problems. The only significant parameters that we vary per problem are the maximum program size, the maximum number of instruction evaluations that a program may use per execution, and the maximum number of generations per run. We used a maximum of 300 generations for every problem besides Number IO, Median, and Smallest, for which we used 200 generations. Maximum program sizes varied more, from 200 to 1000 instructions depending on anticipated problem difficulty. We limited instruction executions to approximately 2 to 5 times the maximum program size, but included some larger values for problems that require many loops. 
%See the reference implementation for the specific values of these parameters.
% (Either: [These are in Table \ref{tableGPParameters}.] or [GIVE BRIEF DESCRIPTION OF EACH AND SAY SEE REFERENCE IMPLEMENTATION WEBSITE FOR DETAILS.]) [I went with the latter for now to take up less space]
By specifying the maximum generations, the population size (1000 for all of our runs), and the size of the training set (see Table \ref{testCasesTable}), we also specify the program evaluation budget, which is the product of those values. In our implementation, this budget falls between 5 and 60 million program evaluations per run for every problem. 
%For other systems, even non-GP systems, to produce comparable results, we recommend using the similar program evaluation budgets, regardless of other system settings.

\section{Experimental Results}

%[TMH: I FEEL LIKE SOMETHING LIKE THE FOLLOWING NEEDS TO BE IN HERE, UNLESS IT'S DISCUSSED LATER IN THIS SECTION]
Where the relevance of a benchmark suite is determined by how well its problems reflect potential applications of the test systems, its utility is based on how well it differentiates between different approaches. We aim to include problems with a large range of difficulties, from those that can be solved reliably to those that extend beyond the abilities of current program synthesis systems. More importantly, we hope to include problems that are solved more often with some systems or settings than others, allowing us to compare their performances on these problems.
In this section we present a simple experiment showing the utility of the benchmark suite presented here. This experiment compares three parent selection algorithms: tournament selection, implicit fitness sharing, and lexicase selection.

Implicit fitness sharing (IFS) is a modification of tournament selection designed to encourage diversity preservation in the population \cite{McKay:2000:GECCO}. IFS selection greatly rewards individuals for solving training cases that are solved by few members of the population, and gives less reward for solving cases that are solved by more of the population. Most of the problems here produce non-binary error values, for which we use the non-binary adaptation of IFS found in \cite{Krawiec:2013:EvoIASP}. As required by this method, we normalize error values to $[0, 1]$ by dividing each error by a maximum allowed error value, which differs per problem based on the fitness function.

Lexicase selection \cite{Helmuth:2014:ieeeTEC}, %, Spector:2012:APM:2330784.2330846}, %maybe remove the second citation here if need space?
 unlike tournament selection and IFS, does not base selection on a single fitness value derived from the errors calculated when running the program on the training set. Instead, it uses a random ordering of the training cases to select individuals that perform as well as possible on a subset of the training cases even if they exhibit poor performance on other cases. Lexicase selection has been shown to improve performance of a GP system on a variety of problems \cite{Helmuth:2014:ieeeTEC, Helmuth:2014:GECCO}. %, Helmuth:2013:GECCOcomp}. %Maybe take out the last reference here if need room

\begin{table}[t]
\centering
\caption{Number of successful runs out of 100 for each setting, where ``Tourney'' is size 7 tournament selection and ``IFS'' is implicit fitness sharing with size 7 tournaments. For each problem, underline indicates significant improvement over the other two selection methods at $p < 0.05$ based on a pairwise chi-square test with Holm correction \cite{R}, or a pairwise Fisher's exact test with Holm correction if any number of successes is below 5 \cite{fmsb}.}
\label{tableResults}
\rowcolors{3}{Gray}{white}
\begin{tabular}{lrrr}
\toprule
Problem                    & Tourney & IFS & Lexicase \\
\midrule
Number IO                  & 68      & 72  & \underline{98}       \\
Small Or Large             & 3       & 3   & 5        \\
For Loop Index             & 0       & 0   & 1        \\
Compare String Lengths     & 3       & 6   & 7        \\
Double Letters             & 0       & 0   & 6        \\
Collatz Numbers            & 0       & 0   & 0        \\
Replace Space with Newline & 8       & 16  & \underline{51}       \\
String Differences         & 0       & 0   & 0        \\
Even Squares               & 0       & 0   & 2        \\
Wallis Pi                  & 0       & 0   & 0        \\
String Lengths Backwards   & 7       & 10  & \underline{66}       \\
Last Index of Zero         & 8       & 4   & \underline{21}       \\
Vector Average             & 14      & 13  & 16       \\
Count Odds                 & 0       & 0   & 8        \\
Mirror Image               & 46      & 64  & \underline{78}       \\
Super Anagrams             & 0       & 0   & 0        \\
Sum of Squares             & 2       & 0   & 6        \\
Vectors Summed             & 0       & 0   & 1        \\
X-Word Lines               & 0       & 0   & \underline{8}        \\
Pig Latin                  & 0       & 0   & 0        \\
Negative To Zero           & 10      & 8   & \underline{45}       \\
Scrabble Score             & 0       & 0   & 2        \\
Word Stats                 & 0       & 0   & 0        \\
Checksum                   & 0       & 0   & 0        \\
Digits                     & 0       & 1   & 7        \\
Grade                      & 0       & 0   & 4        \\
Median                     & 7       & 43  & 45       \\
Smallest                   & 75      & \underline{98}  & 81       \\
Syllables                  & 1       & 7   & 18       \\
\midrule
\rowcolor{white} Problems Solved          & 13       & 13      & 22   \\
\bottomrule
\end{tabular}
\end{table}


Table \ref{tableResults} gives the results of our parent selection experiment. Over the 29 problems, PushGP with lexicase selection produced at least one successful run on nine more problems than either tournament selection or IFS.
Additionally, there were 8 problems where lexicase selection achieved a significantly higher number of successful runs than the other two, where IFS showed significant improvement on just one problem and tournament selection none. These results strongly indicate the utility of lexicase selection for general program synthesis problems.

The data in Table \ref{tableResults} only reflect solutions that generalize by achieving zero error on the unseen test set. Some problems seem to lend themselves to generalization more than others; for example, PushGP using lexicase selection found 14 programs with zero error on the training set for the Super Anagrams problem, none of which generalized to the test set. For lexicase selection, five problems resulted in 20 or more runs that passed the training set that did not generalize (Small Or Large,
Compare String Lengths,
Last Index of Zero,
Negative To Zero,
Median),
and five problems with between 10 and 20 runs that did not generalize (String Lengths Backwards,
Mirror Image,
Digits,
Smallest,
Super Anagrams).
These 10 problems show an important area for future study: how to evolve programs that generalize to unseen data for general program synthesis problems. Among these problems are the only five in the suite that give a correct/incorrect binary error as fitness in our implementation: Compare String Lengths, Mirror Image, Super Anagrams, Median, Smallest. This shows the difficulty of evolving general programs based entirely on correctness of output, and suggests that these problems might be better tackled if they can be transformed into problems with more informative outputs.

%Problems with >= 20 non-generalizing using lexicase:
%Small Or Large
%Compare String Lengths
%Last Index of Zero
%Negative To Zero
%Median
%
%Problems with [10, 20] non-generalizing using lexicase:
%String Lengths Backwards
%Mirror Image
%Digits
%Smallest
%Super Anagrams (none generalize)

With regards to the problems themselves, this experiment illustrates the ability of this benchmark suite to provide useful comparisons between multiple systems or parameter settings. By looking at the number of problems solved by each technique, and how often each technique showed significant improvements over the others, we can clearly see that lexicase selection increases PushGP's ability to solve general program synthesis problems compared to tournament selection and implicit fitness sharing. The main goal of a benchmark suite is to support this type of experiment. Additionally, some problems in the suite were solved frequently by each system, where others were solved infrequently or not at all. This range of difficulties allows the suite to be useful for a variety of experiments, and allows it to remain relevant as program synthesis systems improve.

Of the seven problems on which PushGP found no generalizing solution, most are not surprising in that they require extensive use of different programming constructs, the linking of many distinct steps, or a deceptive fitness space where fitness improvements do not lead toward perfect programs. 
%The lexicase selection runs found 14 non-generalizing solutions to the Super Anagrams problem, suggesting that it may be solvable, but that issues of generalization must be addressed to reliably generate general solution. 
Finally, we have written solutions to each of the unsolved problems ourselves to ensure that each problem is solvable within the constraints we make on the system and instruction set.


Maybe something about smallest sizes of found programs here.

%(Should we give the minimum size of a solution found by GP?
%probably should use simplified programs.
%gives idea of how large would need to search with something like brute-force search.)
% -- probably not enough space, though it's interesting. I looked into it, and minimum sizes tend to be between 6 and 20, though a few were higher up to 53. This is in Push points (i.e. the count-points function), since it is looking at simplified Push programs.

%I mean the sizes of the smallest simplified generalizing programs for each problem. I've scraped these sizes for the lexicase runs in the light green columns here. I think it's interesting in that it shows that a few of the problems have solution programs to be conceivably findable by brute-force search (probably only those with program sizes less than ~7, depending on the instruction set size). For example, the smallest program size with a small instruction set in our runs is for the Number IO problem, which found a solution with 6 instructions with an instruction set of size 50. Brute force testing every program of size 6 would require testing 6^50 programs on our 25 training cases, needing at most 3.9  10^11 program evaluations. We limited our runs to 5 * 10^5 evaluations, so much fewer. I'm sure other analytic synthesis methods can do much better than brute force, but that's a lot of ground to make up even on the simplest problem here. On the problems with smallest known solutions with 20+ instructions out of a 100+ instruction set, I doubt most analytic methods have a chance.
%
%Anyway, the reason I'm going into all of this is because one thing I think is important to emphasize in this paper that I'm not sure we've emphasized enough is that these problems use significantly bigger instruction sets and require significantly larger solution programs than other automatic program synthesis results I've seen, both inside and outside of GP. This is important for pushing the field forward and making sure we're not just using toy problems. I think that should be one of the big messages here, and showing that the problems require larger solution programs is part of that message.
%
%As for actually fitting something into the paper, one option is to add another column to the results table showing minimum sizes. I'm not sure if that would actually fit, and might be overkill. The other option is to have a short paragraph summarizing the data, saying things like "4 problems had smallest solutions between 5 and 10 instructions long, ...". I guess a third way would be a small table or figure that showed the summarized data. I'll think about this as I work on the paper today.



\section{Conclusions}

We have presented a suite of $29$ general program synthesis benchmark problems, systematically selected from sources of introductory computer science programming problems. 
The problems are appropriate for experiments with any program synthesis system driven by input/output examples. 
We presented the criteria that we used to select the problems, we described the chosen problems in natural language, and we outlined the additional decisions that must be made in order to apply a program synthesis system to these problems. We have also provided recommendations for analysis of results of program synthesis experiments using our benchmarks.

As an illustrative example we presented the results of an experiment that used the benchmarks to assess the utility of three different parent selection methods in the PushGP system.% \cite{spector:2002:GPEM, 1068292}.
The results of the specific experiment strongly suggest that lexicase selection %\cite{Helmuth:2014:ieeeTEC}
 is more useful than either standard tournament selection or implicit fitness sharing %\cite{McKay:2000:GECCO,Krawiec:2013:EvoIASP}
 in this context. The more general lesson of this experiment, however, is that the problems in the presented benchmark suite vary in difficulty, and that they can be useful for assessing the capabilities of a program synthesis system.

[AS IS, THE CONCLUSIONS ARE A LITTLE WEAK -- JUST A RECAP OF THE PAPER. CAN WE GET MORE SUBSTANCE IN HERE? What can the suite provide in the future?]


%ACKNOWLEDGMENTS are optional
\section{Acknowledgments}
Omitted for blind review.

%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{gpBenchmarksReferences}  % sigproc.bib is the name of the Bibliography in this case
% You must have a proper ``.bib'' file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
%APPENDICES are optional
%\balancecolumns
%\appendix
%%Appendix A
%\section{Headings in Appendices}
%The rules about hierarchical headings discussed above for
%the body of the article are different in the appendices.
%In the \textbf{appendix} environment, the command
%\textbf{section} is used to
%indicate the start of each Appendix, with alphabetic order
%designation (i.e. the first is A, the second B, etc.) and
%a title (if you include one).  So, if you need
%hierarchical structure
%\textit{within} an Appendix, start with \textbf{subsection} as the
%highest level. Here is an outline of the body of this
%document in Appendix-appropriate form:
%\subsection{Introduction}
%\subsection{The Body of the Paper}
%\subsubsection{Type Changes and  Special Characters}
%\subsubsection{Math Equations}
%\paragraph{Inline (In-text) Equations}
%\paragraph{Display Equations}
%\subsubsection{Citations}
%\subsubsection{Tables}
%\subsubsection{Figures}
%\subsubsection{Theorem-like Constructs}
%\subsubsection*{A ' for the \TeX\ Expert}
%\subsection{Conclusions}
%\subsection{Acknowledgments}
%\subsection{Additional Authors}
%This section is inserted by \LaTeX; you do not insert it.
%You just add the names and information in the
%\texttt{{\char'134}additionalauthors} command at the start
%of the document.
%\subsection{References}
%Generated by bibtex from your ~.bib file.  Run latex,
%then bibtex, then latex twice (to resolve references)
%to create the ~.bbl file.  Insert that ~.bbl file into
%the .tex source file and comment out
%the command \texttt{{\char'134}thebibliography}.
%% This next section command marks the start of
%% Appendix B, and does not continue the present hierarchy
%\section{More Help for the Hardy}
%The sig-alternate.cls file itself is chock-full of succinct
%and helpful comments.  If you consider yourself a moderately
%experienced to expert user of \LaTeX, you may find reading
%it useful but please remember not to change it.
%%\balancecolumns % GM June 2007
%% That's all folks!

\end{document}
